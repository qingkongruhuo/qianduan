## 1、axios
Axios 是专注于网络数据请求的库。要导包
相比于原生的 XMLHttpRequest 对象，axios 简单易用。
相比于 jQuery，axios 更加[轻量化]，只专注于网络数据请求。
语法：
    axios.get('url', { params: { /*参数*/ } }).then(callback)
    axios.post('url', { /*参数*/ }).then(callback)
具体实例：
post请求：
```js
// 请求的 URL 地址
 var url = 'http://www.liulongbin.top:3006/api/post'
 // 要提交到服务器的数据
 var dataObj = { location: '北京', address: '顺义' }
 // 调用 axios.post() 发起 POST 请求
 axios.post(url, dataObj).then(function(res) {
     // res.data 是服务器返回的数据
     var result = res.data
     console.log(result)
 })
```
get请求
```js
// 请求的 URL 地址
 var url = 'http://www.liulongbin.top:3006/api/get'
 // 请求的参数对象
 var paramsObj = { name: 'zs', age: 20 }
 // 调用 axios.get() 发起 GET 请求
 axios.get(url, { params: paramsObj }).then(function(res) {
     // res.data 是服务器返回的数据
     var result = res.data
     console.log(res)
 })

```

也可以直接使用axios发起请求
注意：post数据写在data里，get参数写在params里
```js
axios({
     method: '请求类型',
     url: '请求的URL地址',
     data: { /* POST数据 */ },
     params: { /* GET参数 */ }
 }) .then(function(res){
     //回调函数
 })

```

## 2、同源策略和跨域
1、什么是同源：
    如果两个页面的协议，域名和端口都相同，则两个页面具有相同的源。
    ps：如果域名后面没写端口号，默认是80
        例如，下表给出了相对于 http://www.test.com/index.html 页面的同源检测：
        http://www.test.com/other.html：同源
        https://www.test.com/about.html：不同源，这个是https协议
        http://blog.test.com/movie.html：不同源，域名不同
        http://www.test.com:7001/home.html：不同源，端口7001
        http://www.test.com:80/main.html:同源
2、同源策略
同源策略（英文全称 Same origin policy）是[浏览器]提供的一个安全功能。
MDN官方给定的概念：同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。

通俗的理解：浏览器规定，A网站的JavaScript，不允许和非同源的网站C之间，进行资源的交互，例如：
    1、无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB
    2、无法接触非同源网页的 DOM
        比如a网站不能用js操作c网站的dom元素
    3、无法向非同源地址发送 Ajax 请求
        a网站无法向c网站发送ajax请求

3、跨域
同源指的是两个 URL 的协议、域名、端口一致，**反之，则是跨域**。
出现跨域的根本原因：浏览器的同源策略不允许非同源的URL之间进行资源的交互。
网页：http://www.test.com/index.html
接口：http://www.api.com/userlist
网页不能向接口发送ajax请求。

浏览器允许发送跨域请求，接口服务器能接收请求，然后响应数据给网页，而且浏览器也能正常接收到跨域响应的数据，但是浏览器因为同源策略给你拦截下来，不会发给ajax。一言蔽之浏览器允许发起跨域请求，但是，跨域请求回来的数据，会被浏览器拦截，无法被页面获取到！

那么如何实现跨域请求：
现如今，实现跨域数据请求，最主要的两种解决方案，分别是 JSONP 和 CORS。
JSONP：出现的早，兼容性好（兼容低版本IE）。是前端程序员为了解决跨域问题，被迫想出来的一种临时解决方案。缺点是[只支持GET请求]，不支持 POST 请求。
CORS：出现的较晚，它是 W3C 标准，属于跨域 Ajax 请求的根本解决方案。支持 GET 和 POST 请求。缺点是不兼容某些低版本的浏览器。

## 3、JSONP
JSONP (JSON with Padding) 是 JSON 的一种['使用模式']，可用于解决主流浏览器的跨域数据访问的问题。
原理：
    由于浏览器同源策略的限制，网页中无法通过 Ajax 请求非同源的接口数据。
但是[<script> 标签不受浏览器同源策略的影响]，可以通过 src 属性，请求非同源的 js 脚本。
    因此，JSONP 的实现原理，就是通过 <script> 标签的 src 属性，请求跨域
的数据接口，并通过[函数调用]的形式，接收跨域接口响应回来的数据

JSONP实现
1、一个页面有两个script标签，第一个标签里定义了一个函数，那么在第二个标签里直接调用这个函数会报错吗？
当然不会，浏览器会把全部的script标签聚合到一起去执行。
2、那第一个script标签里定义一个函数，在一个js文件中去执行这个函数，可以执行吗？
当然可以，只需要在另一个script标签中定义一个src属性，把你的js文件路径写到src属性里就可以了。
3、更进一步，第一个script标签里定义一个函数，想在其它服务器上去请求一个脚本，让这个脚本调用我们的函数，可以吗？
同样可以，只需要在script标签里的src属性中，填入服务器的url地址，就可以了，并在？后面通过查询字符串你的形式，填入数据
```js
 <script>
   function success(data) {
     console.log('获取到了data数据：')
     console.log(data)
   }
 </script>
//通过 <script> 标签，请求接口数据：
<script src="http://ajax.frontend.itheima.net:3006/api/jsonp?callback=success&name=zs&age=20"></script>

//callback：在请求脚本的时候告诉他要调用什么函数
//在后面就是请求数据了。
```
所以JSONP通过url来请求接口，数据都写在url中，只能是get请求。没法支持post请求。

jsonp和ajax无任何关系。jsonp没用到XMLHttpRequest。

## 4、jquery中的JSONP
jQuery 提供的 $.ajax() 函数，除了可以发起真正的 Ajax 数据请求之外，还能够发起 JSONP 数据请求，例如：
```js
$.ajax({
    //url后面要写请求参数
    url: 'http://ajax.frontend.itheima.net:3006/api/jsonp?name=zs&age=20',
    // 如果要使用 $.ajax() 发起 JSONP 请求，必须指定 datatype 为 jsonp
    dataType: 'jsonp',//重点！
    success: function(res) {
       console.log(res)
    }
 })

```
默认情况下，使用 jQuery 发起 JSONP 请求，会自动携带一个 callback=jQueryxxx 的参数，jQueryxxx 是随机生成的一个回调函数名称。
当然可以手动指定回调函数名称和jsonp的参数
```js
 $.ajax({
    url: 'http://ajax.frontend.itheima.net:3006/api/jsonp?name=zs&age=20',
    dataType: 'jsonp',
    // 发送到服务端的参数名称，默认值为 callback,下面这么写就把callback改成了callback1111 = abc  
    jsonp: 'callback1111',
    // 自定义的回调函数名称，默认值为 jQueryxxx 格式
    jsonpCallback: 'abc',
    success: function(res) {
       console.log(res)
    }
 })
```

实现：
    咱们自己的实现，是写死script标签的，不过jquery是动态的。
    jQuery 中的 JSONP，也是通过 <script> 标签的 src 属性实现跨域数据访
问的，只不过，jQuery 采用的是动态创建和移除 <script> 标签的方式，来发起 JSONP 数据请求。
    在发起 JSONP 请求的时候，动态向 <header> 中 append 一个 <script> 
标签；
    在 JSONP 请求成功以后，动态从 <header> 中移除刚才 append 进去的 
<script> 标签；
完整代码

```

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script src="./lib/jquery.js"></script>
</head>

<body>
  <button id="btnJSONP">发起JSONP数据请求</button>

  <script>
    $(function () {
      $('#btnJSONP').on('click', function () {
        $.ajax({
          url: 'http://ajax.frontend.itheima.net:3006/api/jsonp?address=北京&location=顺义',
          dataType: 'jsonp',
          jsonpCallback: 'abc',
          success: function (res) {
            console.log(res)
          }
        })
      })
    })
  </script>
</body>

</html>
```

## 5、防抖和节流
防抖策略（debounce）是当事件被触发后，延迟 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。
应用场景：
    用户在输入框中连续输入一串字符时，可以通过防抖策略，只在输入完后，才执行
查询的请求，这样可以有效减少请求次数，节约请求资源；
    比如我搜索apple，直接蹦出来5次请求，只有最后一个apple输完的请求才是有效的。

实现防抖的输入框
```js
 var timer = null                    // 1. 防抖动的 timer

 function debounceSearch(keywords) { // 2. 定义防抖的函数
    timer = setTimeout(function() {
    // 发起 JSONP 请求
    getSuggestList(keywords)
    }, 500)
 }

 $('#ipt').on('keyup', function() {  // 3. 在触发 keyup 事件时，立即清空 timer
    clearTimeout(timer)
    // ...省略其他代码
    debounceSearch(keywords)
 })

```
节流：顾名思义，可以减少一段时间内事件的触发频率。比如鼠标滚轮事件，让它一秒内执行一次，滑多次没用。
防抖：和节流不一样，是事件延迟n秒触发回调，比如1秒，那么触发了事件0.5秒后再次触发，会刷新1秒的时间，如果无限次下去，会一直不触发回调函数，因为回调函数一直是1s后触发，但是节流，就是1秒内能触发一次事件，只要1s到了就可以再次触发。     
节流应用场景：
1、鼠标连续不断地触发某事件（如点击），只在单位时间内只触发一次；
2、懒加载时要监听计算滚动条的位置，但不必每次滑动都触发，可以降低计算的频率，而不必去浪费 CPU 资源；

节流阀
    高铁卫生间是否被占用，由红绿灯控制，红灯表示被占用，绿灯表示可使用。
    假设每个人上卫生间都需要花费5分钟，则五分钟之内，被占用的卫生间无法被其他人使用。
    上一个人使用完毕后，需要将红灯重置为绿灯，表示下一个人可以使用卫生间。
    下一个人在上卫生间之前，需要先判断控制灯是否为绿色，来知晓能否上卫生间。

    节流阀为空，表示可以执行下次操作；不为空，表示不能执行下次操作。
    当前操作执行完，必须将节流阀重置为空，表示可以执行下次操作了。
    每次执行操作前，必须先判断节流阀是否为空。
```js
$(function() {
  var angel = $('#angel')
  var timer = null // 1.预定义一个 timer 节流阀
  $(document).on('mousemove', function(e) {
    if (timer) { return } // 3.判断节流阀是否为空，如果不为空，则证明距离上次执行间隔不足16毫秒
    timer = setTimeout(function() {
      $(angel).css('left', e.pageX + 'px').css('top', e.pageY + 'px')
      timer = null // 2.当设置了鼠标跟随效果后，清空 timer 节流阀，方便下次开启延时器
    }, 16)
  })
})

```

## http协议建议看ppt ,