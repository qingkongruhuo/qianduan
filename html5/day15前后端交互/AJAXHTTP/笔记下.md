## 1、axios
Axios 是专注于网络数据请求的库。要导包
相比于原生的 XMLHttpRequest 对象，axios 简单易用。
相比于 jQuery，axios 更加[轻量化]，只专注于网络数据请求。
语法：
    axios.get('url', { params: { /*参数*/ } }).then(callback)
    axios.post('url', { /*参数*/ }).then(callback)
具体实例：
post请求：
```js
// 请求的 URL 地址
 var url = 'http://www.liulongbin.top:3006/api/post'
 // 要提交到服务器的数据
 var dataObj = { location: '北京', address: '顺义' }
 // 调用 axios.post() 发起 POST 请求
 axios.post(url, dataObj).then(function(res) {
     // res.data 是服务器返回的数据
     var result = res.data
     console.log(result)
 })
```
get请求
```js
// 请求的 URL 地址
 var url = 'http://www.liulongbin.top:3006/api/get'
 // 请求的参数对象
 var paramsObj = { name: 'zs', age: 20 }
 // 调用 axios.get() 发起 GET 请求
 axios.get(url, { params: paramsObj }).then(function(res) {
     // res.data 是服务器返回的数据
     var result = res.data
     console.log(res)
 })

```

也可以直接使用axios发起请求
注意：post数据写在data里，get参数写在params里
```js
axios({
     method: '请求类型',
     url: '请求的URL地址',
     data: { /* POST数据 */ },
     params: { /* GET参数 */ }
 }) .then(function(res){
     //回调函数
 })

```

## 2、同源策略和跨域
1、什么是同源：
    如果两个页面的协议，域名和端口都相同，则两个页面具有相同的源。
    ps：如果域名后面没写端口号，默认是80
        例如，下表给出了相对于 http://www.test.com/index.html 页面的同源检测：
        http://www.test.com/other.html：同源
        https://www.test.com/about.html：不同源，这个是https协议
        http://blog.test.com/movie.html：不同源，域名不同
        http://www.test.com:7001/home.html：不同源，端口7001
        http://www.test.com:80/main.html:同源
2、同源策略
同源策略（英文全称 Same origin policy）是[浏览器]提供的一个安全功能。
MDN官方给定的概念：同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。

通俗的理解：浏览器规定，A网站的JavaScript，不允许和非同源的网站C之间，进行资源的交互，例如：
    1、无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB
    2、无法接触非同源网页的 DOM
        比如a网站不能用js操作c网站的dom元素
    3、无法向非同源地址发送 Ajax 请求
        a网站无法向c网站发送ajax请求

3、跨域
同源指的是两个 URL 的协议、域名、端口一致，**反之，则是跨域**。
出现跨域的根本原因：浏览器的同源策略不允许非同源的URL之间进行资源的交互。
网页：http://www.test.com/index.html
接口：http://www.api.com/userlist
网页不能向接口发送ajax请求。

浏览器允许发送跨域请求，接口服务器能接收请求，然后响应数据给网页，而且浏览器也能正常接收到跨域响应的数据，但是浏览器因为同源策略给你拦截下来，不会发给ajax。一言蔽之浏览器允许发起跨域请求，但是，跨域请求回来的数据，会被浏览器拦截，无法被页面获取到！

那么如何实现跨域请求：
现如今，实现跨域数据请求，最主要的两种解决方案，分别是 JSONP 和 CORS。
JSONP：出现的早，兼容性好（兼容低版本IE）。是前端程序员为了解决跨域问题，被迫想出来的一种临时解决方案。缺点是[只支持GET请求]，不支持 POST 请求。
CORS：出现的较晚，它是 W3C 标准，属于跨域 Ajax 请求的根本解决方案。支持 GET 和 POST 请求。缺点是不兼容某些低版本的浏览器。

## 3、JSONP
JSONP (JSON with Padding) 是 JSON 的一种['使用模式']，可用于解决主流浏览器的跨域数据访问的问题。
原理：
    由于浏览器同源策略的限制，网页中无法通过 Ajax 请求非同源的接口数据。
但是[<script> 标签不受浏览器同源策略的影响]，可以通过 src 属性，请求非同源的 js 脚本。
    因此，JSONP 的实现原理，就是通过 <script> 标签的 src 属性，请求跨域
的数据接口，并通过[函数调用]的形式，接收跨域接口响应回来的数据

JSONP实现
1、一个页面有两个script标签，第一个标签里定义了一个函数，那么在第二个标签里直接调用这个函数会报错吗？
当然不会，浏览器会把全部的script标签聚合到一起去执行。
2、那第一个script标签里定义一个函数，在一个js文件中去执行这个函数，可以执行吗？
当然可以，只需要在另一个script标签中定义一个src属性，把你的js文件路径写到src属性里就可以了。
3、更进一步，第一个script标签里定义一个函数，想在其它服务器上去请求一个脚本，让这个脚本调用我们的函数，可以吗？
同样可以，只需要在script标签里的src属性中，填入服务器的url地址，就可以了，并在？后面通过查询字符串你的形式，填入数据
```js
 <script>
   function success(data) {
     console.log('获取到了data数据：')
     console.log(data)
   }
 </script>
//通过 <script> 标签，请求接口数据：
<script src="http://ajax.frontend.itheima.net:3006/api/jsonp?callback=success&name=zs&age=20"></script>

//callback：在请求脚本的时候告诉他要调用什么函数
//在后面就是请求数据了。
```
所以JSONP通过url来请求接口，数据都写在url中，只能是get请求。没法支持post请求。

jsonp和ajax无任何关系。jsonp没用到XMLHttpRequest。

## 4、jquery中的JSONP
jQuery 提供的 $.ajax() 函数，除了可以发起真正的 Ajax 数据请求之外，还能够发起 JSONP 数据请求，例如：
```js
$.ajax({
    //url后面要写请求参数
    url: 'http://ajax.frontend.itheima.net:3006/api/jsonp?name=zs&age=20',
    // 如果要使用 $.ajax() 发起 JSONP 请求，必须指定 datatype 为 jsonp
    dataType: 'jsonp',//重点！
    success: function(res) {
       console.log(res)
    }
 })

```
默认情况下，使用 jQuery 发起 JSONP 请求，会自动携带一个 callback=jQueryxxx 的参数，jQueryxxx 是随机生成的一个回调函数名称。
当然可以手动指定回调函数名称和jsonp的参数
```js
 $.ajax({
    url: 'http://ajax.frontend.itheima.net:3006/api/jsonp?name=zs&age=20',
    dataType: 'jsonp',
    // 发送到服务端的参数名称，默认值为 callback,下面这么写就把callback改成了callback1111 = abc  
    jsonp: 'callback1111',
    // 自定义的回调函数名称，默认值为 jQueryxxx 格式
    jsonpCallback: 'abc',
    success: function(res) {
       console.log(res)
    }
 })
```

实现：
    咱们自己的实现，是写死script标签的，不过jquery是动态的。
    jQuery 中的 JSONP，也是通过 <script> 标签的 src 属性实现跨域数据访
问的，只不过，jQuery 采用的是动态创建和移除 <script> 标签的方式，来发起 JSONP 数据请求。
    在发起 JSONP 请求的时候，动态向 <header> 中 append 一个 <script> 
标签；
    在 JSONP 请求成功以后，动态从 <header> 中移除刚才 append 进去的 
<script> 标签；
完整代码

```

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script src="./lib/jquery.js"></script>
</head>

<body>
  <button id="btnJSONP">发起JSONP数据请求</button>

  <script>
    $(function () {
      $('#btnJSONP').on('click', function () {
        $.ajax({
          url: 'http://ajax.frontend.itheima.net:3006/api/jsonp?address=北京&location=顺义',
          dataType: 'jsonp',
          jsonpCallback: 'abc',
          success: function (res) {
            console.log(res)
          }
        })
      })
    })
  </script>
</body>

</html>
```