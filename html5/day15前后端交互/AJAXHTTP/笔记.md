## 1、客户端与服务器端
上网的目的：通过互联网的形式来获取和消费资源。
服务器：
    上网过程中负责存放和对外提供资源的电脑叫服务器。
客户端：
    上网过程中获取和消费资源的电脑（自己的电脑）
## 2、URL
Uniform Resource Location统一资源定位符用于标识互联网每个资源的唯一存放位置。浏览器只有通过URL地址，才能正确定位资源存放的位置，从而成功访问到对应的资源。
http://www.baidu.com
一般有三部分组成
    1、客户端与服务器之间的协议
    2、存放该资源的服务器名称
    3、资源在服务器上具体存放的位置
http://www.cnblogs.com/liulongbinblogs/p/116.html
http通信协议
www.cnblogs.com：存放该资源的服务器名称
后面的：具体位置
## 3、服务器对外提供资源
文字内容、图片、音频、视频、数据等。
数据是网页的灵魂，数据是服务器对外提供的一种资源，只要是资源，必然要
经过**请求、处理、响应**的方式进行获取
客户端请求，服务器处理，服务器把数据响应给客户端，
如果要在网页中请求服务器上的资源数据，需要用到**XMLHttpRequest**对象。
XMLHttpRequest简称xhr是浏览器提供的js成员，通过它可以请求服务器上的数据资源。 
最简单的用法：
    var xhrObj = new XMLHttpRequest()

## 4、资源的请求方式
get、post最常用的两种请求方式
get通常用于获取服务器资源（向服务器要资源）
    比如根据uRL地址，从服务器获取html文件，css文件，js文件，图片，数据资源等。
post请求通常用于向服务器提交数据（往服务器发资源）
    比如登录时提交的账号密码，注册的信息等提交多种数据

## 5、AJAX
Asynchronous Javascript And XML异步js和XML
通俗理解：在网页中利用XMLHttpRequest对象和服务器进行数据交互的方式就是Ajax。
之前学的技术只能把网页做的更美观更漂亮，或者添加一些动画效果，但是Ajax能让我们轻松实现网页与服务器之间的数据交互。
用户操作网页，网页中利用ajax实现与服务器的数据交互。
比如注册界面
    填写用户名密码手机，通过ajax动态检测用户名是否被占用等。
比如搜索提示
    输入我，后面出来是大傻子
比如数据的分页显示。

## 6、 Jquery中的Ajax
浏览器中提供的XMLHttpRequest用法比较复杂，jQuery对XMLHttpRequest进行了封装，提供了一系列ajax相关的函数，大大降低了ajax的使用难度。 
在浏览器工具中，network的xhr里可以查看这些ajax请求。
$.get():专门用来发起get请求，从而将服务器上的资源请求到客户端进行使用。
    $.get(url,[data可选],[callback可选])
    第一个url是字符串那类型必选，要请求的资源地址。
    data是object，不是必选项，表示请求资源器件要携带的参数
    callback是function，不是必选项，请求成功的回调函数，在回调中拿到服务器响应的数据。
```js
//发起不带参数的请求
$.get('http://www.baidu.com',function(res){console.log(res)})//res是服务器返回的数据。
//发起带参数的请求
$.get('http://www.baidu.com',{id:1},function(res){console.log(res)})
```
$.post():专门用来发起post请求，从而向服务器提交数据
    $.post(url,[data可选],[callback可选])
    第一个url是字符串那类型必选，要提交数据的地址。
    data是object，不是必选项，表示要提交的数据
    callback是function，不是必选项，数据提交成功的回调函数，在回调中拿到服务器响应的数据。
```js
$.post('http://www.baidu.com',{id:1},function(res){console.log(res)})
```
$.ajax():它既可以发get也可以发post
```js
$.ajax({
    type:'',//请求方式，比如GET或POST
    url:'',//地址
    data:{},//请求要携带的数据
    success: function(res){}//回调函数
})
//发送post请求演示
$.ajax({
   type: 'POST', // 请求的方式
   url: 'http://www.liulongbin.top:3006/api/addbook',  // 请求的 URL 地址
   data: { // 要提交给服务器的数据
      bookname: '水浒传',
      author: '施耐庵',
      publisher: '上海图书出版社'
    },
   success: function(res) { // 请求成功之后的回调函数
       console.log(res)
   }
})

```

## 7、接口
使用Ajax请求数据的时候，被请求的url地址就叫做数据接口，同时**每个接口必须有请求方式**。
例如
http://www.liulongbin.top:3006/api/getbooks  获取图书列表的接口(GET请求)
http://www.liulongbin.top:3006/api/addbook   添加图书的接口（POST请求）

接口测试工具：为了验证接口能否被正常被访问，我们常常需要使用接口测试工具，来对数据接口进行检测。
好处：接口测试工具能让我们在不写任何代码的情况下，对接口进行调用和测试。
POSTMAN，ppt
http://www.liulongbin.top:3006/api/getbooks，下面id写1可以看到请求过来的图书信息

接口文档，顾名思义就是接口的说明文档，它是我们调用接口的依据。好的接口文档包含了对接口URL，参数以及输出内容的说明，我们参照接口文档就能方便的知道接口的作用，以及接口如何进行调用。

接口文档的组成部分：
接口文档可以包含很多信息，也可以按需进行精简，不过，一个合格的接口文档，应该包含以下6项内容，从而为接口的调用提供依据：
    1、接口名称：用来标识各个接口的简单说明，如登录接口，获取图书列表接口等。
    2、接口URL：接口的调用地址。
    3、调用方式：接口的调用方式，如 GET 或 POST。
    4、参数格式：接口需要传递的参数，每个参数必须包含参数名称、参数类型、是否必选、参数说明这4项内容。
    5、响应格式：接口的返回值的详细描述，一般包含数据名称、数据类型、说明3项内容。
    6、返回示例（可选）：通过对象的形式，例举服务器返回数据的结构。

PPt上有上面图书接口的文档示例。

## 8、表单
<form>
    <input>
    <button>
    ...
</form>

1、form标签的属性
    1、action：属性用来规定当提交表单时，向何处发送表单数据。
        action 属性的值应该是后端提供的一个 URL 地址，这个URL地址专门负责接收表单提交过来的数据。
        当 <form> 表单在未指定 action 属性值的情况下，action的默认值为当前页面的 URL 地址。
        注意：当提交表单后，页面会立即跳转到 action 属性指定的 URL 地址
    2、target 属性用来规定在何处打开 action URL。
        它的可选值有5个，默认情况下，target 的值是 _self，表示在相同的框架中打开action URL。
        _blank：在新窗口中打开。
        <form tatget="_blank"></form>
    3、method属性用来规定以何种方式把表单数据提交到 action URL。
        它的可选值有两个，分别是get和post。
        默认情况下，method的值为get，表示通过URL地址的形式，把表单数据提交到 action URL。
        ？前面是请求的url地址，？后面就是get请求提交的表单数据
        post请求看不到数据。隐藏在header里
        注意：
        get 方式适合用来提交少量的、简单的数据。
        post 方式适合用来提交大量的、复杂的、或包含文件上传的数据。
        在实际开发中，<form> 表单的 post 提交方式用的最多，很少用 get。例如登录、注册、添加数据等表单操作，都需要使用 post 方式来提交表单。
    4、enctype属性用来规定在发送表单数据之前如何对数据进行编码。
        它的可选值有三个，默认情况下，enctype 的值为 applicationx-www-form-urlencoded，表示在发送前编码所有的字符。
        multipart/form-data不对字符编码。在使用包含文件上传控件的表单时，必须使用该值。
        注意：
        在涉及到文件上传的操作时，必须将 enctype 的值设置为 multipart/form-data。
        如果表单的提交不涉及到文件上传操作，则直接将 enctype 的值设置为 application/x-www-form-urlencoded 即可。！
2、表单同步提交
    1、通过点击 submit 按钮，触发表单提交的操作，从而使页面跳转到 action URL 的行为，叫做表单的同步提交。
    2、缺点：
    <form>表单同步提交后，整个页面会发生跳转，跳转到 action URL 所指向的地址，用户体验很差。
    <form>表单同步提交后，页面之前的状态和数据会丢失。
    3、解决：
    表单只负责采集数据，Ajax 负责将数据提交到服务器。这样页面就不会跳转，体验就很好了
3、通过Ajax提交表单数据
    1、监听表单提交事件：在 jQuery 中，可以使用如下两种方式，监听到表单的提交事件：
    $('#form1').submit(function(e) {
        alert('监听到了表单的提交事件')
    })
    $('#form1').on('submit', function(e) {
    alert('监听到了表单的提交事件')
    })
    只要被监听的form触发了submit事件，jquery就能监听到并获取信息
    2、阻止表单提交的默认行为：当监听到表单的提交事件以后，可以调用**事件对象**的 event.preventDefault() 函数，来阻止表单的提交和页面的跳转，示例代码如下：
    $('#form1').submit(function(e) {
    // 阻止表单的提交和页面的跳转
    e.preventDefault()
    })

    $('#form1').on('submit', function(e) {
    // 阻止表单的提交和页面的跳转
    e.preventDefault()
    })

    还有一种方法，在submit按钮绑定一个click事件，return false

    3、快速获取表单中的数据
        1、serialize()函数：为了简化表单中数据的获取操作，jQuery 提供了 serialize() 函数，其语法格式如下：
        $(form表单选择器).serialize()
        serialize() 函数的好处：可以一次性获取到表单中的所有的数据。
```html
<form id="form1">
    <input type="text" name="username" />
    <input type="password" name="password" />
    <button type="submit">提交</button>
</form>
```
```js
$('#form1').serialize()
// 调用的结果：
// username=用户名的值&password=密码的值

```
    注意：在使用 serialize() 函数快速获取表单数据时，必须为每个表单元素添加'name'属性！


## 9、模板引擎
1、渲染UI结构时遇到的问题
```js
var rows = []
$.each(res.data, function (i, item) { // 循环拼接字符串
    rows.push('<li class="list-group-item">'+ item.content +'<span class="badge cmt-date">评论时间：'+ item.time +'</span><span class="badge cmt-person">评论人：'+ item.username +'</span></li>')
})
$('#cmt-list').empty().append(rows.join('')) // 渲染列表的UI结构
```
上述代码是通过字符串拼接的形式，来渲染UI结构。如果UI结构比较复杂，则拼接字符串的时候需要格外注意引号之前的嵌套。且一旦需求发生变化，修改起来也非常麻烦。
2、模板引擎：顾名思义，它可以根据程序员指定的模板结构和数据，自动生成一个完整的HTML页面。
    减少了字符串的拼接操作、
    使代码结构更清晰、
    使代码更易于阅读与维护
3、art-template模板引擎是一个简约、超快的模板引擎
art-template 下载到本地，然后，通过 <script> 标签加载到网页上进行使用。
    使用步骤：
        1、导包
        2、定义数据
        3、定义模板
        4、调用template函数
        5、渲染html结构
    看ppt
模板引擎实现没看
 
## 10、xhr基本使用
1、XMLHttpRequest（简称 xhr）是浏览器提供的 Javascript 对象，通过它，可以请求服务器上的数据资源。之前所学的 jQuery 中的 Ajax 函数，就是基于 xhr 对象封装出来的。
2、使用xhr发起不带参数GET请求
    1、创建 xhr 对象
    2、调用 xhr.open() 函数
    3、调用 xhr.send() 函数
    4、监听 xhr.onreadystatechange 事件
```js
// 1. 创建 XHR 对象
var xhr = new XMLHttpRequest()
// 2. 调用 open 函数，指定 请求方式 与 URL地址
xhr.open('GET', 'http://www.liulongbin.top:3006/api/getbooks')
// 3. 调用 send 函数，发起 Ajax 请求
xhr.send()
// 4. 监听 onreadystatechange 事件
xhr.onreadystatechange = function() {
    // 4.1 监听 xhr 对象的请求状态 readyState ；与服务器响应的状态 status,固定的写法，4和200 
    if (xhr.readyState === 4 && xhr.status === 200) {
        // 4.2 打印服务器响应回来的数据
        console.log(xhr.responseText)
    }
}

```
3、xmr对象的redayState属性表示当前Ajax请求所处的状态，每个Ajax请求必然处于下面五个状态之一
    0 UNSENT XMLHttpRequest 对象已被创建，但尚未调用 open方法。
    1 OPENED open() 方法已经被调用。
    2 HEADERS_RECEIVED send() 方法已经被调用，响应头也已经被接收。
    3 LOADING 数据接收中，此时 response 属性中已经包含部分数据。
    4 DONE Ajax 请求完成，这意味着数据传输已经彻底完成或失败。
4、发送带参数的请求
    参数写在url中，用？隔开
xhr.open('GET', 'http://www.liulongbin.top:3006/api/getbooks?id=1')
    这种在 URL 地址后面拼接的参数，叫做查询字符串
```js
// 1. 创建 XHR 对象
var xhr = new XMLHttpRequest()
// 2. 调用 open 函数，指定 请求方式 与 URL地址 
xhr.open('GET', 'http://www.liulongbin.top:3006/api/getbooks?id=1')
// 3. 调用 send 函数，发起 Ajax 请求
xhr.send()
// 4. 监听 onreadystatechange 事件
xhr.onreadystatechange = function() {
    // 4.1 监听 xhr 对象的请求状态 readyState ；与服务器响应的状态 status,固定的写法，4和200 
    if (xhr.readyState === 4 && xhr.status === 200) {
        // 4.2 打印服务器响应回来的数据
        console.log(xhr.responseText)
    }
}

```

5、查询字符串
定义：查询字符串（URL 参数）是指在 URL 的末尾加上用于向服务器发送信息的字符串（变量）。
格式：将英文的 ? 放在URL 的末尾，然后再加上 参数＝值 ，想加上多个参数的话，使用 & 符号进行分隔。以这个形式，可以将想要发送给服务器的数据添加到 URL 中。
带两个参数的url地址
http://www.liulongbin.top:3006/api/getbooks?id=1&bookname=西游记
6、get请求携带参数的本质
无论使用 $.ajax()，还是使用 $.get()，又或者直接使用 xhr 对象发起 GET 请求，当需要携带参数的时候，本质上，都是直接将参数以查询字符串的形式，追加到 URL 地址的后面，发送到服务器的。
```js
$.get('url', {name: 'zs', age: 20}, function() {})
// 等价于
$.get('url?name=zs&age=20', function() {})

$.ajax({ method: 'GET', url: 'url', data: {name: 'zs', age: 20}, success: function() {} })
// 等价于
$.ajax({ method: 'GET', url: 'url?name=zs&age=20', success: function() {} })

```

7、url编码
URL 地址中，只允许出现英文相关的字母、标点符号、数字，因此，在 URL 地址中不允许出现中文字符。
如果 URL 中需要包含中文这样的字符，则必须对中文字符进行编码（转义）。
URL编码的原则：使用安全的字符（没有特殊用途或者特殊意义的可打印字符）去表示那些不安全的字符。
URL编码原则的通俗理解：使用英文字符去表示非英文字符。
```js
http://www.liulongbin.top:3006/api/getbooks?id=1&bookname=西游记

// 经过 URL 编码之后，URL地址变成了如下格式：

http://www.liulongbin.top:3006/api/getbooks?id=1&bookname=%E8%A5%BF%E6%B8%B8%E8%AE%B0

```

8、url编码解码
浏览器提供了 URL 编码与解码的 API，分别是：
encodeURI()  编码的函数
decodeURI()  解码的函数
```js
var str = encodeURI('黑马程序员')
console.log(str);
// 输出字符串  %E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98
str = decodeURI('%E9%BB%91%E9%A9%AC')
console.log(str); 
// 输出字符串  黑马

```
由于浏览器会自动对 URL 地址进行编码操作，因此，大多数情况下，程序员不需要关心 URL 地址的编码与解码操作。

9、使用xhr发送post请求
比get请求多了一步 设置 Content-Type 属性，就按固定写法写就行了
然后查询字符串写在send里面，之前get请求查询字符串写在了url里面
```js
// 1. 创建 xhr 对象
var xhr = new XMLHttpRequest()
// 2. 调用 open()
xhr.open('POST', 'http://www.liulongbin.top:3006/api/addbook')
// 3. 设置 Content-Type 属性（固定写法）
xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded')
// 4. 调用 send()，同时将数据以查询字符串的形式，提交给服务器
xhr.send('bookname=水浒传&author=施耐庵&publisher=天津图书出版社')
// 5. 监听 onreadystatechange 事件
xhr.onreadystatechange = function() {
    if (xhr.readyState === 4 && xhr.status === 200) {
        console.log(xhr.responseText)
    }
}

```

## 11、数据交换格式
数据交换格式，就是服务器端与客户端之间进行数据传输与交换的格式。
前端领域，经常提及的两种数据交换格式分别是 XML 和 JSON。其中 XML 用的非常少，所以，我们重点要学习的数据交换格式就是 JSON。
1、XML
    1、XML 的英文全称是 EXtensible Markup Language，即可扩展标记语言。因此，XML 和 HTML 类似，也是一种标记语言。
    2、XML和html的区别
        XML 和 HTML 虽然都是标记语言，但是，它们两者之间没有任何的关系。
        HTML 被设计用来描述网页上的内容，是网页内容的载体
        XML 被设计用来传输和存储数据，是数据的载体
    3、XML的缺点
        XML 格式臃肿，和数据无关的代码多，体积大，传输效率低
        在 Javascript 中解析 XML 比较麻烦
2、JSON
    1、概念：JSON 的英文全称是 JavaScript Object Notation，即“JavaScript 对象表示法”。简单来讲，JSON 就是 Javascript 对象和数组的字符串表示法，它使用文本表示一个 JS 对象或数组的信息，因此，JSON 的本质是字符串。
    2、作用：JSON 是一种轻量级的文本数据交换格式，在作用上类似于 XML，专门用于存储和传输数据，但是 JSON 比 XML 更小、更快、更易解析。
    3、现状：JSON 是在 2001 年开始被推广和使用的数据格式，到现今为止，JSON 已经成为了主流的数据交换格式。
3、JSON的两种格式
        JSON 就是用字符串来表示 Javascript 的对象和数组。所以，JSON 中
    包含对象和数组两种结构，通过这两种结构的相互嵌套，可以表示各种复杂的数据结构。
    1、对象结构
        对象结构：对象结构在 JSON 中表示为 { } 括起来的内容。数据结构为 { key: value, key: value, … } 的键值对结构。其中，key 必须是使用英文的双引号包裹的字符串，value 的数据类型可以是数字、字符串、布尔值、null、数组、对象6种类型。
        **不允许出现undefined和function**
    {
    "name": "zs",
    "age": 20,
    "gender": "男",
    "address": null,
    "hobby": ["吃饭", "睡觉", "打豆豆"]
    }
        不能有function
    2、数组解构
        数组结构在 JSON 中表示为 [ ] 括起来的内容。数据结构为 [ "java", "javascript", 30, true … ] 。数组中数据的类型可以是数字、字符串、布尔值、null、数组、对象6种类型。
    下面这些都是合法的
    [ "java", "python", "php" ]
    [ 100, 200, 300.5 ]
    [ true, false, null ]
    [ { "name": "zs", "age": 20}, { "name": "ls", "age": 30} ]
    [ [ "苹果", "榴莲", "椰子" ], [ 4, 50, 5 ] ]
4、JSON注意事项：
    1、属性名必须使用双引号包裹
    2、字符串类型的值必须使用双引号包裹
    3、JSON 中**不允许使用单引号**表示字符串
    4、JSON 中不能写注释
    5、JSON 的最外层必须是对象或数组格式
    6、不能使用 undefined 或函数作为 JSON 的值
    JSON 的作用：在计算机与网络之间存储和传输数据。
    JSON 的本质：用字符串来表示 Javascript 对象数据或数组数据
5、json和js对象
JSON 是 JS 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串
转换方法：
```js
//这是一个对象
var obj = {a: 'Hello', b: 'World'}

//这是一个 JSON 字符串，本质是一个字符串
var json = '{"a": "Hello", "b": "World"}' 

var obj = JSON.parse('{"a": "Hello", "b": "World"}')
//结果是 {a: 'Hello', b: 'World'}

var json = JSON.stringify({a: 'Hello', b: 'World'})
//结果是 '{"a": "Hello", "b": "World"}'

```
**之前服务器响应的数据res携带的数据都是json字符串**
比如xhr对象的得到的响应数据xhr.responseText就是json字符串

6、序列化和反序列化
    把数据对象转为字符串的过程为序列化，比如JSON.stringify()
    把字符串转为数据对象的过程叫反序列化，比如JSON.prise(str)

## 12、封装自己的Ajax函数
1、要达到的效果：
```html
<!-- 1. 导入自定义的ajax函数库 -->
<script src="./itheima.js"></script>

<script>
    // 2. 调用自定义的 itheima 函数，发起 Ajax 数据请求
    itheima({
        method: '请求类型',
        url: '请求地址',
        data: { /* 请求参数对象 */ },
        success: function(res) { // 成功的回调函数
            console.log(res)     // 打印数据
        }
    })
</script>

```

## 13、XMLHttpRequest Level2的新特性
1、旧版XHR缺点：
    1、只支持文本数据的传输，无法用来读取和上传文件
    2、传送和接收数据时，没有进度信息，只能提示有没有完成
2、XMLHttpRequest Level2的新功能
    1、可以设置 HTTP 请求的时限
    2、可以使用 FormData 对象管理表单数据
        之前只能用form标签,用jquery的$(form).serialize()获取表单数据
    3、可以上传文件
    4、可以获得数据传输的进度信息
2.1、设置 HTTP 请求的时限
    有时，Ajax 操作很耗时，而且无法预知要花多少时间。如果网速很慢，用户可能要等很久。新版本的 XMLHttpRequest 对象，增加了 timeout 属性，可以设置 HTTP 请求的时限：
```js
var xhr = new XMLHttpRequest();
xhr.timeout = 3000;
//上面的语句，将最长等待时间设为 3000 毫秒。过了这个时限，就自动停止HTTP请求。与之配套的还有一个 timeout 事件，用来指定回调函数：
xhr.ontimeout = function(event){
    alert('请求超时！')
}

```
2.2、可以使用 FormData 对象管理表单数据
Ajax 操作往往用来提交表单数据。为了方便表单处理，HTML5 新增了一个 FormData 对象，可以模拟表单操作：
```js
// 1. 新建 FormData 对象
      var fd = new FormData()
      // 2. 为 FormData 添加表单项
      fd.append('uname', 'zs')
      fd.append('upwd', '123456')
      // 3. 创建 XHR 对象
      var xhr = new XMLHttpRequest()
      // 4. 指定请求类型与URL地址 
      xhr.open('POST', 'http://www.liulongbin.top:3006/api/formdata')
      // 5. 直接提交 FormData 对象，这与提交网页表单的效果，完全一样
      xhr.send(fd)

```
FormData对象也可以用来获取网页表单的值。
```js
 // 获取表单元素querySelector获取选择器的数据
 var form = document.querySelector('#form1')
 // 监听表单元素的 submit 事件
 form.addEventListener('submit', function(e) {
    //取消默认行为，因为想用Ajax的方式来提交数据
    e.preventDefault()

    // 根据 form 表单创建 FormData 对象，会自动将表单数据填充到 FormData 对象中，直接把表单元素作为实参传入new FormData()构造函数中
    //var data = $(this).serialize();//之前是用这个,
    var fd = new FormData(form)
    var xhr = new XMLHttpRequest()
    xhr.open('POST', 'http://www.liulongbin.top:3006/api/formdata')
    xhr.send(fd)
    xhr.onreadystatechange = function() {}
})
```

2.3、上传文件
步骤：
   1、 定义 UI 结构
```html
<!-- 1. 文件选择框,typt="file" -->
    <input type="file" id="file1" />
    <!-- 2. 上传按钮 -->
    <button id="btnUpload">上传文件</button>
    <br />
    <!-- 3. 显示上传到服务器上的图片，这此次例子中的服务器就是把上传上去的图片再传回来，这个标签是来显示这张图片的，纯纯就是为了来操作一次上传文件的流程-->
    <img src="" alt="" id="img" width="800" />
```
   2、 验证是否选择了文件
```js
 // 1. 获取上传文件的按钮
 var btnUpload = document.querySelector('#btnUpload')
 // 2. 为按钮添加 click 事件监听,点了上传按钮看看是否上传了文件。
 btnUpload.addEventListener('click', function() {
     // 3. 获取到选择的文件列表，然后查看里面的文件（是一个数组）
     var files = document.querySelector('#file1').files
     if (files.length <= 0) {
         //文件数组长度小于等于0，肯定是没上传文件
         return alert('请选择要上传的文件！')
     }
     // ...后续业务逻辑
 })

```
   3、 向 FormData 中追加文件
```js
 // 1. 创建 FormData 对象
 var fd = new FormData()
 // 2. 向 FormData 中追加文件,文件名是avatar，内容是刚才获取到的文件列表的某个元素
 fd.append('avatar', files[0])

```
   4、 使用 xhr 发起上传文件的请求
   **上传文件必须是post请求**
```js
 // 1. 创建 xhr 对象
 var xhr = new XMLHttpRequest()
 // 2. 调用 open 函数，指定请求类型与URL地址。其中，请求类型必须为 POST
 xhr.open('POST', 'http://www.liulongbin.top:3006/api/upload/avatar')
 // 3. 发起请求
 xhr.send(fd)
```
   5、 监听 onreadystatechange 事件
```js

xhr.onreadystatechange = function() {
  if (xhr.readyState === 4 && xhr.status === 200) {
    var data = JSON.parse(xhr.responseText)
    if (data.status === 200) { // 上传文件成功
      // 将服务器返回的图片地址，设置为 <img> 标签的 src 属性
      document.querySelector('#img').src = 'http://www.liulongbin.top:3006' + data.url
    } else { // 上传文件失败
      console.log(data.message)
    }
  }
}

```
2.4、显示文件上传进度：新版本的 XMLHttpRequest 对象中，可以通过监听 
xhr.upload.onprogress 事件，来获取到文件的上传进度。 
语法格式如下：
```js
// 创建 XHR 对象
 var xhr = new XMLHttpRequest()
 // 监听 xhr.upload 的 onprogress 事件,不是直接监听xhr
 xhr.upload.onprogress = function(e) {
    // e.lengthComputable 是一个布尔值，表示当前上传的资源是否具有可计算的长度
    if (e.lengthComputable) {
        // e.loaded 已传输的字节
        // e.total  需传输的总字节
        var percentComplete = Math.ceil((e.loaded / e.total) * 100)
    }
 }
```
监听上传完成的事件：
xhr.upload.onload = function(){

}


完整代码
```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <link rel="stylesheet" href="./lib/bootstrap.css" />
  <script src="./lib/jquery.js"></script>
</head>

<body>
  <!-- 1. 文件选择框 -->
  <input type="file" id="file1" />
  <!-- 2. 上传文件的按钮 -->
  <button id="btnUpload">上传文件</button>

  <!-- bootstrap 中的进度条 -->
  <div class="progress" style="width: 500px; margin: 15px 10px;">
    <div class="progress-bar progress-bar-striped active" style="width: 0%" id="percent">
      0%
    </div>
  </div>

  <br />
  <!-- 3. img 标签，来显示上传成功以后的图片 -->
  <img src="" alt="" id="img" width="800" />

  <script>
    // 1. 获取到文件上传按钮
    var btnUpload = document.querySelector('#btnUpload')
    // 2. 为按钮绑定单击事件处理函数
    btnUpload.addEventListener('click', function () {
      // 3. 获取到用户选择的文件列表
      var files = document.querySelector('#file1').files
      if (files.length <= 0) {
        return alert('请选择要上传的文件！')
      }
      var fd = new FormData()
      // 将用户选择的文件，添加到 FormData 中
      fd.append('avatar', files[0])

      var xhr = new XMLHttpRequest()

      // 监听文件上传的进度
      xhr.upload.onprogress = function (e) {
        if (e.lengthComputable) {
          // 计算出上传的进度
          var procentComplete = Math.ceil((e.loaded / e.total) * 100)
          console.log(procentComplete)
          // 动态设置进度条
          $('#percent').attr('style', 'width: ' + procentComplete + '%;').html(procentComplete + '%')
        }
      }

      xhr.upload.onload = function () {
        //完成后删除全部的样式，然后给一个绿色的上传成功的样式。
        $('#percent').removeClass().addClass('progress-bar progress-bar-success')
      }

      xhr.open('POST', 'http://www.liulongbin.top:3006/api/upload/avatar')
      xhr.send(fd)

      xhr.onreadystatechange = function () {
        if (xhr.readyState === 4 && xhr.status === 200) {
          var data = JSON.parse(xhr.responseText)
          if (data.status === 200) {
            // 上传成功
            document.querySelector('#img').src = 'http://www.liulongbin.top:3006' + data.url
          } else {
            // 上传失败
            console.log('图片上传失败！' + data.message)
          }
        }
      }
    })
  </script>
</body>

</html>
```

[上面用的是底层xhr来搞的，用jquery会特别快，用jquery来实现一遍。]
processData: false,
contentType: false,
记得设置
```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script src="./lib/jquery.js"></script>
</head>

<body>
    <!-- 文件选择框 -->
  <input type="file" id="file1" />
  <button id="btnUpload">上传文件</button>

  <br />
  <img src="./images/loading.gif" alt="" style="display: none;" id="loading" />

  <script>
    $(function () {
      // 监听到Ajax请求被发起了。Ajax 请求开始时，执行 ajaxStart 函数
      //这个$(document)是监听整个文档的ajax请求
      $(document).ajaxStart(function () {
        $('#loading').show()
      })

      // 监听到 Ajax 完成的事件 Ajax 请求结束时，执行 ajaxStop 函数
      $(document).ajaxStop(function () {
        $('#loading').hide()
      })

      $('#btnUpload').on('click', function () {
        //[0]将jquery对象转成dom对象
        var files = $('#file1')[0].files
        if (files.length <= 0) {
          return alert('请选择文件后再上传！')
        }
        //FormData对象jquery同样可以用
        var fd = new FormData()
        fd.append('avatar', files[0])

        // 发起 jQuery 的 Ajax 请求，上传文件
        $.ajax({
          method: 'POST',
          url: 'http://www.liulongbin.top:3006/api/upload/avatar',
          data: fd,
          //true。默认情况下，通过data选项传递进来的数据，如果是一个对象(技术上讲只要不是字符串)，都会处理转化成一个查询字符串
          processData: false,
          // ajax 中 contentType 设置为 false 是为了避免 JQuery 对其操作，从而失去分界符，而使服务器不能正常解析文件。
          contentType: false,
          success: function (res) {
            console.log(res)
          }
        })
      })
    })
  </script>

</body>

</html>
```

