# JS 进阶	第一天

## 一、DOM

## 1.1 JavaScript

javascript这门语言是由DOM、BOM、ECMAScript组成

 DOM指的是: document object model 文档对象模型 体现在代码中是document

 BOM指的是: browser object model 浏览器对象模型 体现在代码中 window

 ECMAScript是 核心语法

    里面包含的是如何定义变量、运算符、表达式、流程控制语句、数据类型

    在js基础部分我们学习的是核心语法，在进阶部分我们学习另外两个

### 1.2 节点操作

对于DOM的操作

 我们可以通过dom的onclick、onmousedown、onmouseup来添加事件

 还可以通过dom的getElementById获取元素

 还可以通过dom的style来设置样式……

### 1.3 节点类型：一个元素是一个结点，但是一个节点不一定是一个元素，有可能是属性，文本等。

DOM是由节点组成的，元素/标签 它们是节点中的某一种，节点一共分为12种，

 元素节点      　 Node.ELEMENT_NODE(1) 

 属性节点       　Node.ATTRIBUTE_NODE(2)

 文本节点       　Node.TEXT_NODE(3) 

 CDATA节点       Node.CDATA_SECTION_NODE(4)用的不多

实体引用名称节点  　　Node.ENTRY_REFERENCE_NODE(5)用的不多

实体名称节点     　 Node.ENTITY_NODE(6)用的不多

处理指令节点    　  Node.PROCESSING_INSTRUCTION_NODE(7)用的不多

注释节点         		Node.COMMENT_NODE(8) 

文档节点      　  	 Node.DOCUMENT_NODE(9)

文档类型节点    　 Node.DOCUMENT_TYPE_NODE(10)

文档片段节点    　 Node.DOCUMENT_FRAGMENT_NODE(11)

DTD声明节点         Node.NOTATION_NODE(12) 

**每一个元素都是一个节点，但是每一个节点不一定是一个元素，元素仅仅是节点的一种**

 	通过nodeType属性判断节点的类型
```html
<div id="box">
	你好，爱创课堂
	<div class="one"></div>
	<!-- 我是一个注释 -->
</div>
<script>
    console.log(document.getElementById("one").nodeType);// 出现1，表示元素节点
<script>
```

**我们需要记住的有四种：非常 重要！**

 	1 元素类型

​	 3 文本类型

​	 8 注释类型

​	 9 文档类型

childNodes属性：该属性指向一个节点的所有子节点的集合，返回的是一个类数组对象

```html
<div id="box">
	你好，爱创课堂
	<div class="one"></div>
	<!-- 我是一个注释 -->
</div>
<script>
    console.log(document.getElementById("app").childNodes.length);
<script>
```

我们明明书写了3个节点，但是现在却输出5个节点

  原因是因为在高级浏览器中，空白折叠现象形成的空白符也会当做一个文本节点存在

  现在我们到IE中观察：我们输出arr.length，结果为3

### 1.4 节点属性

节点三个常用的属性：

 nodeType: 标记的是节点的类型

 nodeName: 标记的是节点的名称

 nodeValue: 标记的是节点的值

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <div id="app">
        你好，爱创课堂//3，#text，你好爱创课堂
        <div class="one"></div>//1，DIV，null
        <!-- 我是一个注释 -->//8，#comment，我是一个注释
    </div>
<script>
// 获取元素
var app = document.getElementById('app');
// 遍历节点，打印类型，名称，与值
for (var i = 0; i < app.childNodes.length; i++) {
    console.log(app.childNodes[i].nodeType);
    console.log(app.childNodes[i].nodeName);
    console.log(app.childNodes[i].nodeValue);
}

// 总结：
// 节点名称
//      元素    元素名称大写
//      文本    #text
//      注释    #comment
// 节点的值
//      元素    null
//      文本    文本内容
//      注释    注释的内容

// 解决兼容性问题：让所有浏览器显示的一致
// 让所有浏览器都输出3，忽略这些换行符
function getNodes(dom) {
    // 返回包含所有节点的数组
    var arr = [];
    // 定义正则
    var reg = /^\s*$/
    // 遍历所有的节点，过滤掉换行符文本节点
    for (var i = 0; i < dom.childNodes.length; i++) {
        // 如果是文本阶段，要过滤掉换行符
        if (dom.childNodes[i].nodeType === 3) {
            // 判断文本的内容， data或者nodeValue
            // console.log(reg.test(dom.childNodes[i].data), dom.childNodes[i].data);
            if (!reg.test(dom.childNodes[i].data)) {
                // 不是换行符，存储节点
                arr.push(dom.childNodes[i])
            }
        } else {
            // 其它类型节点，直接存储节点
            arr.push(dom.childNodes[i])
        }
    }
    // 返回结果
    return arr;
}
</script>
</body>
</html>
```



### 1.5 节点关系

在节点关系中可以分为三种

 父子

​		 father.childNodes // 获取所有的子节点

​		 father.firstChild // 获取到第一个子节点

​		 father.lastChild // 获取到最后一个子节点
  子父

​		 child.parentNode // 获取到父节点

 兄弟

​		 node.nextSibling // 获取到下一个兄弟节点

​		 node.previousSibing // 获取到上一个兄弟节点

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <div id="app"><ul><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li></ul></div>
<script>
// 获取元素
var app = document.getElementById('app');
// 获取ul
var ul = app.getElementsByTagName('ul')[0]

// 节点关系
// 获取所有子节点
console.log(ul.childNodes)
// 第一个子节点
console.log(ul.firstChild)
// 最后一个子节点
console.log(ul.lastChild)

// 获取第五个li
var li = ul.childNodes[4];
// console.log(li);
// 获取父节点
console.log(li.parentNode);

// 兄弟节点
console.log(li.previousSibling);
console.log(li.nextSibling);
// 修改下一个节点的背景色
li.nextSibling.style.backgroundColor = 'pink';


</script>
</body>
</html>
```



### 1.6 节点操作

**创建元素**

​	 使用方式：document.createElment(type)

​	 type: 创建的类型 是一个字符串 

​	 返回值: 创建出来的元素

​	 创建文本：document.createTextNode(content)

​	 content：表示文档内容  
    .innerHTML("")，里面写标签同样会生效的

**节点上树** （将节点渲染到页面中，上dom树）

​	 使用方式：father.appendChild(child)

​	 child：要追加的子元素 

 	father: 父元素

​	 返回值： child 

​	 最终的效果: **child作为father的最后一个子节点存在**

```js
    // 创建h1元素
    var h1 = document.createElement('h1');
    // 设置内容
    var text = document.createTextNode('hello<strong>ickt</strong>');
    // 下面两种方式有区别，第一个是吧文本当做节点加入，里面的strong标签不会生效（当成文本），但是直接.innerHTML加进去里面的strong标签会生效！
    h1.appendChile(text);
    h1.innerHTML = 'hello<strong>ickt</strong>';
```

**节点下树**（从页面中删除节点）

​	 使用方式：father.removeChild(child)

​	 child： 要被移除的子元素 

​	 father: 父元素

​	 返回值: child 

​	 最终效果: child从father的所有子节点中移除

**节点插入**

​	 使用方式：father.insertBefore(newChild, oldChild)

​	 newChild: 要插入的元素 

 	oldChild: 参照元素，

​	注意： oldChild如果是null，即没有参考元素，会添加到最后面，相当于appendChild方法。但是null必须写（妈的如果这么干为什么不appendChild）
（当然可以用这个写另一个方法：insertAfter(parent,child,oldChild),）
```js
    function insertAfter(parent, child, oldChild) {
        // 插入
        return parent.insertBefore(child, oldChild.nextSibling)//先获取这个oldChild的下一个元素，然后插在下一个之前就行了，不怕oldChild是最后一个，因为最后一个元素的下一个是undefined，insertBefore(child,undefined)也是插在最后
    }
```

​	 返回值：newChild 

​	 最终效果: newChild追加到oldChild的前面作为它的兄弟节点存在

**节点替换**

​	 使用方式：father.replaceChild(newChild, oldChild)

​	 newChild: 要被替换上的元素 

​	 oldChild: 被替换下的元素

​	 返回值: oldChild

​	 最终效果: newChild替换掉oldChild

**节点克隆**
    为什么要克隆：比如用getElementById()获取得到了一个元素，如果把这个元素直接插入到其它位置，那么这个元素之前在的位置就没有这个元素了!所以想多次用某个元素必须要先克隆。

​	 使用方式：node.cloneNode(bool) 

​	 bool： 是一个布尔值，默认是一个false , 只复制自身，如果传递的是true表示连同子节点一起复制，**var newnode = node.cloneNode()只复制node本身，node.cloneNode(true)连同node的子节点也全复制。**

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <div id="app"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div></div>
    <div id="app2">
        <ul>
            <li>1</li>
            hello
            <li>2</li>
            <!-- hello -->
            <li>
                <div>
                    <h2><span>hello</span></h2>
                </div>
            </li>
        </ul>
    </div>
    <div id="app3"></div>
    <script>
    // 获取容器元素
    var app = document.getElementById('app');
    // 创建h1元素
    var h1 = document.createElement('h1');
    // 设置内容
    var text = document.createTextNode('hello<strong>ickt</strong>');
    // 下面两种方式有区别，第一个是吧文本当做节点加入，里面的strong标签不会生效（当成文本），但是直接.innerHTML加进去里面的strong标签会生效！
    h1.appendChile(text);
    h1.innerHTML = 'hello<strong>ickt</strong>';
    
    // h1替换div3
    // var result = app.replaceChild(h1, app.childNodes[2])
    // console.log(result);

    // 将ul放入app3中
    // 获取ul
    var ul = document.getElementById('app2').getElementsByTagName('ul')[0]
    // 放入app3
    var app3 = document.getElementById('app3');
    // 插入
    // app3.appendChild(ul)
    // 对于一个元素的操作，只能存储在一个容器中，不能同时存储在两个容器中

    // 为了让两个容器都有ul，我们要复制
    // var ul2 = ul.cloneNode();
    // 深度复制（复制子节点）
    var ul2 = ul.cloneNode(true);
    // app3插入ul2
    var result = app3.appendChild(ul2);
    console.log(result);
    </script>
</body>
</html>
```



### 1.7 jQuery 操作

创建元素：可以利用$函数的功能创建一个元素，返回一个jQuery对象。
var h1 = $('<h1></h1>');或var h1 = $('<h1/>'),有内容使用第一种，没内容使用第二种。

jQuery中的上树方法：在jquery中上树的方式有很多种，可以是父元素选择子元素，也可以是子元素选择父元素，还可以是兄弟选择兄弟（注意：这些方法只能通过jQuery对象使用，源生js对象无法直接使用）。

 父元素选择子元素:

​	 $(father).append(child)：在father的后面追加child元素

​	 $(father).prepend(child): 在father的前面追加child元素

 子元素选择父元素:

​	 $(child).appendTo(father): 将child追加到father的最后去

​	 $(child).prependTo(father): 将child追加到father的前面去

兄弟选择兄弟:

​	 $(dom).after(element): 在dom的后面追加element元素

​	 $(dom).before(element)： 在dom的前面追加elment元素

​	 $(dom).insertBefore(element): 在element的前面追加dom元素

​	 $(dom).insertAfter(element): 在element的后面追加dom元素

节点外部包装：wrap 与 wrapAll， 
```js
// 逐个包装,在id为app下的所有div，每一个都包上'<div class="demo" />'
$('#app div').wrap('<div class="demo" />')
// 整体包装，在id为app下的所有div，这些div全体一起被'<div class="demo" />'包上
$('#app div').wrapAll('<div class="demo" />')
```

去掉外层节点：unwrap，jq对象.unwrap();

元素替换：replaceWith与replaceAll  

清空后代：empty(),全部后代子元素全没了 

删除元素：remove(),谁调用就把谁删了，我杀我自己

克隆元素：clone(bool)

 	bool: 是一个布尔值，默认是false, 连同子节点一起复制，如果传递true, 连同子元素及其事件一起复制

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <div id="app">
        <div>1</div>
        <div>2</div>
        <div class="box">3</div>
        <div>4</div>
        <div>5</div>
    </div>
    <hr>
    <div id="app2">
        <div>11</div>
        <div>22</div>
        <div class="box2">33</div>
        <div>44</div>
        <div>55</div>
    </div>
<script src="./jquery.js"></script>
<script>
// 创建节点
// 如果有内容，建议使用第一种，没有内容，建议使用第二种
// var h1 = $('<h1></h1>')
// var h1 = $('<h1 />')
// console.log(h1);

// 创建h1
var h1 = $('<h1>hello ickt</h1>')
// 上树
// $('#app').prepend(h1)
// $('#app').append(h1)
// 子节点调用
// h1.appendTo('#app')
// h1.prependTo('#app')

// div3的前后插入元素
// $('.box').before($('.box2'));
// $('.box').after($('.box2'));
// $('.box').insertBefore('.box2')
// $('.box').insertAfter('.box2')


// 外部包装
// 逐个包装
// $('#app div').wrap('<div class="demo" />')
// 整体包装
// $('#app div').wrapAll('<div class="demo" />')

// 去掉外部包装
// $('#app div').unwrap()

// 替换元素
// 前面替换后面的
// $('#app div').replaceWith('<h1>hello</h1>')
// 后面的替换前面的
// $('#app div').replaceAll('#app2')

// 清空后代
// $('#app').empty()

// 删除元素
// $('#app').remove()

// 克隆
// 绑定事件
$('.box').click(function() {
    console.log(1111)
})
// 深度克隆
var copy = $('#app').clone(true);
$('#app2').append(copy)
copy.find('.box').css('background', 'pink')

</script>
</body>
</html>
```

# JS 进阶 	第二天

## 一、this

### 1.1 更改this指向

call与apply这两个方法都是函数天生可以调用的方法，它们的作用是执行函数并改变函数的上下文对象（this）

 正常情况下: 谁调用函数，函数的this就指向谁

call：该方法用于执行函数并改变函数的上下文对象。该方法接收多个参数

  第一个参数就是要改变的this指向对象

  从第二个参数开始都是传递给原函数的参数

apply：该方法也是执行函数并改变函数的上下文对象，它与call方法之间的区别是参数的区别。

 该方法接收两个参数

 第一个参数要改变的this指向对象

 第二个参数是一个数组，数组中的每一项都是传递的参数

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <button id="btn">按钮</button>
    <script>
    // 定义方法
    function fun() {
        // 让this指向document对象
        console.log(this, arguments)
    }
    // 执行
    // fun();

    // 通过call改变this指向
    fun.call(document, 1, 2, 3)//打印#document,arguments(3)
    // 通过apply改变this指向
    fun.apply(document, [1, 2, 3])//和上面打印的一样



    // 对象
    // var obj = {
    //     a: fun
    // }
    //fun();//打印window，是window调用的在浏览器端，全局的this指向window
    // // 执行对象的a方法
    // obj.a();，(不看argument)this打印object，即obj对象
    // // document.getElementById('btn')   btn
    // btn.onclick = fun;//button对象调用的，打印button元素
    // document.body.onclick = fun//打印body元素，事件冒泡产生的
    </script>
</body>
</html>
```



## 二、事件

### 2.1 事件流程

整个事件流程分为捕获和冒泡:

 捕获: 事件从最顶层元素开始执行，一层一层往下执行， 直到最精确的元素
    
 冒泡: 事件从最精确的元素开始执行，一层一层往上执行， 直到最顶层的元素
 举例：div1包含div2包含div3，给他们仨挨个绑定onClick事件，打印1，2，3
    当你点击div3的时候，会依次打印3，2，1
    点击事件捕获：先被div1捕获，然后div2，然后div3，然后开始事件冒泡，因为点击的是div3，最精确开始执行，然后往上div2，然后div1.

 当一个元素处于最精确的元素的时候，是不区分捕获和冒泡的

之前学习的事件绑定，属于DOM0级的事件绑定，是绑定在冒泡阶段的，是在事件冒泡阶段执行的，即上面的规则
完整流程: 事件捕获找到元素，触发事件，事件冒泡到最顶层元素。

### 2.2 DOM2级事件绑定（没有dom1级事件，因为dom1对事件没拓展。）

事件名称: addEventListener

 每一个元素都可以使用该方法（像window等对象也可以使用）

 使用方式：dom.addEventListener(type, fn, bool)

 type: 事件的类型

  注意: 不带on的事件类型 例如: click 、 mousedown、 mouseup

  fn: 执行函数

  bool：它是一个布尔值，表示是否在捕获阶段绑定

  默认是false，表示绑定到冒泡阶段，如果是true则表示绑定到捕获阶段，即最上面的例子，这么绑之后，会打印123。

  **一般不这么干。。。**

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        #box1 {
            width: 500px;
            height: 500px;
            background-color: pink;
            margin: 0 auto;
        }
        #box2 {
            width: 300px;
            height: 300px;
            background-color: skyblue;
        }
        #box3 {
            width: 100px;
            height: 100px;
            background-color: green;
        }
    </style>
</head>
<body>
    <div id="box1">box1
        <div id="box2">box2
            <div id="box3">box3</div>
        </div>
    </div>
    <script>
    // 获取元素
    var box1 = document.getElementById('box1');
    var box2 = document.getElementById('box2');
    var box3 = document.getElementById('box3');

    // 之前学习的事件绑定，属于DOM0级事件绑定
    // DOM0级事件绑定中，是在事件冒泡阶段执行的。

    // dom2级事件绑定
    // // 默认绑定在冒泡阶段
    // box1.addEventListener('click', function() {
    //     console.log('box1');
    // })
    // box2.addEventListener('click', function() {
    //     console.log('box2');
    // })
    // box3.addEventListener('click', function() {
    //     console.log('box3');
    // })

    // 绑定在捕获阶段
    box1.addEventListener('click', function() {
        console.log('box1');
    }, true)
    box2.addEventListener('click', function() {
        console.log('box2');
    }, true)
    box3.addEventListener('click', function() {
        console.log('box3');
    }, true)

    // 注意：为了让各级别的事件绑定执行顺序统一，我们常常绑定在冒泡阶段。
    </script>
</body>
</html>
```



### 2.3 IE事件绑定

经过测试， 我们发现在IE中是不支持addEventListner方法，支持自己的attachEvent绑定事件方式

 使用方式：dom.attachEvent(type, fn)

 type： 事件类型 

  注： 是带on的事件类型 

  例如: onclick 、onmousedown、onmouseup

 fn: 要执行的函数

 没有第三个参数，也就是说不支持捕获，只能绑定在冒泡阶段

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        #box1 {
            width: 500px;
            height: 500px;
            background-color: pink;
            margin: 0 auto;
        }
        #box2 {
            width: 300px;
            height: 300px;
            background-color: skyblue;
        }
        #box3 {
            width: 100px;
            height: 100px;
            background-color: green;
        }
    </style>
</head>
<body>
    <div id="box1">box1
        <div id="box2">box2
            <div id="box3">box3</div>
        </div>
    </div>
    <script>
    // 获取元素
    var box1 = document.getElementById('box1');
    var box2 = document.getElementById('box2');
    var box3 = document.getElementById('box3');

    // box3.addEventListener('click', function() {
    //     alert('box3');
    // })

    // ie下不支持addEventListener，要使用attachEvent
    box1.attachEvent('onclick', function() {
        console.log('box1')
    })
    box2.attachEvent('onclick', function() {
        console.log('box2')
    })
    box3.attachEvent('onclick', function() {
        console.log('box3')
    })
    </script>
</body>
</html>
```



### 2.4 DOM2级与DOM0级区别

绑定数量

 dom0级事件: 只能够给一个元素的一个事件绑定一个函数
    如果连着绑定多个，后面的会覆盖前面的
    btn.onclick(function(){
        console.log("1")
    })
    btn.onclick(function(){
        console.log("2")
    })
    会打印2

 dom2级事件: 能够给一个元素的一个事件绑定多个函数
    按照顺序来，而且不受DOM0级别事件影响。

执行顺序

 是按照代码的绑定顺序执行

是否可以同时存在

 DOM2级可以，不受DOM0级事件的影响

this指向

 都指向触发事件的元素

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <button id="btn">按钮</button>
    <script>
    // 获取按钮
    var btn = document.getElementById('btn');


    // 按照绑定顺序执行
    // btn.addEventListener('click', function() {
    //     console.log('addEventListener', 333, this)
    // })

    // // 绑定事件
    // btn.onclick = function() {
    //     console.log('click1', 111)
    // }
    // // 将原有的缓存
    // var fn = btn.onclick;
    // // 后面的覆盖前面的
    // btn.onclick = function() {
    //     // 先执行缓存的,在执行后面的语句，这不脱裤子放屁吗，直接把俩函数写在一起不就行了。
    //     fn();
    //     console.log('click2', 222, this)
    // }
    // // var obj = {};
    // // obj.color = 'red';
    // // obj.color = 'green';
    // // console.log(obj);

    // // dom2级
    // btn.addEventListener('click', function() {
    //     console.log('addEventListener', 111)
    // })
    // btn.addEventListener('click', function() {
    //     console.log('addEventListener', 222, this)
    // })

    // 对象中的方法
    var obj = {
        fun: function() {
            console.log('123', this)
        }
    }
    obj.fun();
    // 不论回调函数存储在哪里,始终指向元素.
    btn.addEventListener('click', obj.fun)
    btn.onclick = obj.fun;
    </script>
</body>
</html>
```



### 2.5 DOM0级与IE的区别

绑定数量

 dom0级: 只能够给一个元素的一个事件绑定一个函数

 attachEvent事件: 可以给一个元素的一个事件绑定多个函数

执行顺序

 优先执行dom0级，然后再逆序执行attachEvent事件，即先绑定的后执行，后绑定的先执行。

是否可以同时存在

attachEvent可以

 this指向

 dom0级: 触发事件的对象。attachEvent: 指向window，可以给绑定事件的回调函数用call绑定dom，这样this指向触发事件的对象了。No3例子。

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <button id="btn">按钮</button>
    <script>
    // 获取按钮
    var btn = document.getElementById('btn');

    
    // btn.attachEvent('onclick', function() {
    //     console.log('attachEvent', 333);
    // })

    // // // 绑定事件
    // btn.onclick = function() {
    //     console.log('click1', 111)
    // }
    // // 后面的覆盖前面的
    // btn.onclick = function() {
    //     console.log('click2', 222, this)
    // }

    // // IE事件绑定
    // btn.attachEvent('onclick', function() {
    //     console.log('attachEvent', 1111);
    // })
    // btn.attachEvent('onclick', function() {
    //     console.log('attachEvent', 222);
    // })


    // 对象中的方法
    var obj = {
        color: 'red',
        fun: function() {
            console.log(123, this);
        }
    }

    // this指向
    // btn.attachEvent('onclick', function() {
    //     console.log('attachEvent', 333, this);
    // })
    btn.attachEvent('onclick', obj.fun);

    // // 绑定事件
    // btn.onclick = function() {
    //     console.log('click1', 111, this)
    // }
    btn.onclick = obj.fun;

    </script>
</body>
</html>
```



### 2.6 移除事件

DOM2级事件移除方式 ：使用removeEventListener方法移除addEventListener绑定的事件

使用方式：元素调用

 dom.removeEventListner(type, fn, bool)

 type: 要移除的事件类型 fn： 执行的函数 bool: 决定了移除哪个阶段的事件函数

总结：

 **匿名函数无法移除，因为移除的时候，要获取函数的引用，因此为了能够移除事件,要为回调函数起名字**

  当绑定多个事件的时候，移除的事件对其它事件没有影响.

 在哪个阶段绑定就要在哪个阶段移除

 **removeEventListener不能移除DOM0级事件，DOM0级事件可以通过dom.onclick = null 形式删除**

 相同的事件回调函数，多次绑定只能保留一个
 总结
    1 匿名函数无法移除,因此为了能够顺利的移除事件,要为回调函数起名字
    2 当绑定多个事件的时候,移除的事件对其它事件没有影响.
    3 在哪个阶段绑定就要在哪个阶段移除,即后面的true和false
    4 removeEventListener不能移除DOM0级事件
        移除dom0级事件:box.onclick = null;
    5 相同的事件回调函数，多次绑定只能保留一个

### 2.7 IE中事件移除

事件移除方式 ：使用detachEvent方法移除attachEvent绑定的事件

使用方式：

 dom.detachEvent(type, fn)

 type: 要移除的事件类型 fn：执行的函数

 使用方式与removeEventListener是一致的，只不过没有了第三个参数而已

总结

 匿名函数无法移除,因此为了能够顺利的移除事件,要为回调函数起名字

 当绑定多个事件的时候,移除的事件对其它事件没有影响.

 detachEvent不能移除DOM0级事件， DOM0级事件可以通过dom.onclick = null 形式删除

 相同事件回调函数多次绑定，会共存，删除的时候要删除多次

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
    #box {
        width: 200px;
        height: 200px;
        background-color: green;
    }
    </style>
</head>
<body>
    <button id="btn">点击按钮,移除box事件</button>
    <hr>
    <div id="box"></div>
    <script>
    // 获取元素
    var btn = document.getElementById('btn');
    var box = document.getElementById('box');
    // 为函数起名字
    function fn() {
        console.log('success', 111);
    }
    // div绑定事件
    // box.addEventListener('click', function() {
    //     console.log('success', 222);
    // })
    box.addEventListener('click', fn)
    box.addEventListener('click', fn)
    // 捕获阶段绑定
    // box.addEventListener('click', fn, true)
    // dom0级绑定的事件
    // box.onclick = fn;
    // 点击按钮移除事件
    btn.onclick = function() {
        // 移除div的事件
        // box.removeEventListener('click', fn)
        // box.removeEventListener('click', fn)
        // 捕获阶段的事件,在捕获阶段移除
        // box.removeEventListener('click', fn, true)
        // box.removeEventListener('click')

        // 移除dom0级事件
        // box.onclick = null;
    }

    // 总结
    // 1 匿名函数无法移除,因此为了能够顺利的移除事件,要为回调函数起名字
    // 2 当绑定多个事件的时候,移除的事件对其它事件没有影响.
    // 3 在哪个阶段绑定就要在哪个阶段移除
    // 4 removeEventListener不能移除DOM0级事件
    // 5 相同的事件回调函数，多次绑定只能保留一个

    // dom0级事件是通过元素的属性形式绑定的,因此删除该属性即可取消绑定.


    // IE事件移除
    // box.attachEvent('onclick', function() {
    //     console.log('click', 2222)
    // })
    // function demo() {
    //     console.log('click', 1111)
    // }
    // // var demo = function() {}
    // box.attachEvent('onclick', demo)
    // box.attachEvent('onclick', demo)
    // // dom0级
    // // box.onclick = demo;
    // // 点击按钮，移除事件
    // btn.onclick = function() {
    //     // 移除事件
    //     // 不同的事件回到函数不能移除
    //     // box.detachEvent('onclick', function() {
    //     //     console.log('click', 1111)
    //     // })
    //     // 不传递回调函数无法移除
    //     // box.detachEvent('onclick')
    //     // 通过函数名移除
    //     box.detachEvent('onclick', demo)
    //     box.detachEvent('onclick', demo)
    //     // box.onclick = null;
    // }
    // 总结
    // 1 匿名函数无法移除,因此为了能够顺利的移除事件,要为回调函数起名字
    // 2 当绑定多个事件的时候,移除的事件对其它事件没有影响.
    // 3 detachEvent不能移除DOM0级事件
    // 4 相同事件回调函数多次绑定，会共存，删除的时候要删除多次
    </script>
</body>
</html>
```
```js 实现绑定并解决兼容性问题的函数。
/***
     * 实现bindEvent
     * @dom     元素
     * @type    事件类型
     * @fn      事件回调函数
     **/
    function bindEvent(dom, type, fn) {
        // 能力检测：判断方法是否存在，存在的话使用，不存在不使用
        if (dom.addEventListener) {
            // dom2级绑定方式, 都在冒泡阶段触发
            dom.addEventListener(type, fn);
        } else if (dom.attachEvent) {
            // 针对ie绑定事件
            dom.attachEvent('on' + type, fn);
        } else {
            // 缓存，目的是多次绑定函数不让后面的覆盖前面的
            //访问属性的两种方式，点语法和中括号语法，因为中括号语法能书写表达式
            var oldFn = dom['on' + type];
            // dom0级绑定方式
            dom['on' + type] = function() {
                // 如果已经绑定过，先执行之前的
                oldFn && oldFn();
                // 再执行新的
                fn();
            }
        }
    }
```



### 2.8 事件对象 重点记忆！！

当事件执行的时候，会产生一系列的信息，这些信息会被浏览器收集起来并**封装为对象传递到事件函数中**
```js
box2.addEventListener('click', function() {
        console.log(argument);
    })//可以看到打印的argument，argument[0]就是事件对象e

onclick 同样可以
```
常用的属性：

 offsetX、offsetY：这两个属性标记的是鼠标位于元素内部的位置（距离padding左上角的位置），会受到子元素的影响（比如div1里面有个div2，你点击了div2，那就算的是距离div2的padding左上角的位置了）

 clientX clientY：这两个属性标记的是鼠标位于视口中的位置（小x, 小y等价）

 pageX pageY：这两个属性标记的是鼠标位于页面中的距离，最左上角为基准（layerX layerY等价）

 默认情况下，当打开页面的时候处于首屏，所以这两个属性和clientX与clientY是相同的，当页面出现滚动条的时候并改变滚动条的位置，此时这些值才会产生差异

 screenX screenY：这两个属性标记了鼠标位于屏幕中的位置，即从屏幕最左上角开始计算的，所以screenX和clientX是一样的值，screenY比clientY多了一个浏览器菜单栏的高度

### 2.9 IE中事件对象

在DOM0级事件中，IE中并没有将事件对象传递到事件函数中

 事件对象存储在window上，获取：window.evnet

 兼容方式： var e = e || window.event
 ```js
 function demo(e){
    e = e|| window.event;
    console.log(e);
 }
 btn.onclick = demo;
 btn.attachEvent('onclick',demo);
 ```

 由于在低版本的IE中无法显示内部结构，所以我们要使用for in循环内部结构

### 2.10 事件总结

dom0级事件：在高级浏览器中可以将事件对象传递进来

 IE中不能将事假对象传递进来

 this指向是触发事件的对象

dom2级事件：可以将事件对象传递到事件函数中

 this指向是触发事件的对象

 执行事件的顺序是代码的绑定顺序

attachEvent事件：可以将事件对象传递到事件函数中

 this指向是window，可以给绑定事件的回调函数用call绑定dom，这样this指向触发事件的对象了。第11个例子。

 执行顺序：优先执行dom0级事件，逆序执行attachEvent事件，

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        #box1 {
            height: 1000px;
            width: 3000px;
            padding-top: 200px;
            background-color: pink;
        }
        #box2 {
            height: 400px;
            border: 100px solid gold;
            background-color: green;
            padding: 100px;
        }
        .box3 {
            width: 100px;
            height: 100px;
            background-color: yellowgreen;
        }
    </style>
</head>
<body>
    <div id="box1">
        <div id="box2">
            <div class="box3"></div>
            <hr>
            <div class="box3"></div>
        </div>
    </div>
    <script>
    // 盒子2绑定事件,通过id绑定事件。事件对象会被作为参数传进事件回调函数的
    box2.addEventListener('click', function(e) {
        // console.log(e);
        console.log('client', e.clientX, e.clientY);
        console.log('screen', e.screenX, e.screenY);
        console.log('offset', e.offsetX, e.offsetY);
        console.log('page', e.pageX, e.pageY);
        console.log('layer', e.layerX, e.layerY);
        console.log('x, y', e.x, e.y);
    })
    // box2.attachEvent('onclick', function(e) {
    //     // console.log(e);
    //     console.log('client', e.clientX, e.clientY);
    //     console.log('screen', e.screenX, e.screenY);
    //     console.log('offset', e.offsetX, e.offsetY);
    //     console.log('page', e.pageX, e.pageY);
    //     console.log('layer', e.layerX, e.layerY);
    //     console.log('x, y', e.x, e.y);
    //     console.log(e);
    // })
    </script>
</body>
</html>
```



### 2.11 事件冒泡

在高级浏览器中阻止冒泡的方式：

 e.stopPropagation();
 比如box1包含box2包含box3，其中box1最大，box2次大，box3最小，每一个都绑定了click事件，打印boxi，那么点击box3，box2和box1都会被打印出来，这是事件的冒泡。如果给box3的回调函数里e.stopPropagation()，这样阻止冒泡，点击box3只会打印box3，只有点击到box2中非box3的位置才会打印box2
 
 如果事件绑定在事件捕获阶段，那么阻止冒泡没吊用了


在IE中阻止冒泡的方式：

 e.cancelBubble = true;

### 2.12 默认行为

一些标签在点击的时候会触发一些默认行为、事件

 比如: 

 submit：默认提交表单

 a标签: 如果有href属性，会默认跳转页面

 当页面中出现滚动条的时候，此时，滚动鼠标滚轮的时候，会默认改变滚动条的位置，这些都是默认事件、行为。

 在高级浏览器中阻止默认事件的方式：e.preventDefault()

 在IE中阻止默认事件的方式：e.returnValue = false;


如果使用的是dom0级事件绑定方式，还可以使用return false阻止默认行为并阻止冒泡,用e.preventDefault()和e.stopPropagation()当然也可以;

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        #box1 {
            width: 500px;
            height: 500px;
            background-color: pink;
            margin: 0 auto;
        }
        #box2 {
            width: 300px;
            height: 300px;
            background-color: skyblue;
        }
        #box3 {
            width: 100px;
            height: 100px;
            background-color: green;
        }
    </style>
</head>
<body>
    <div id="box1">box1
        <div id="box2">box2
            <div id = "box3">box3</div>
            //看事件冒泡把下面的注释，看取消默认行为把上面的注释
            <a href="https://www.baidu.com" id="box3">box3</a>
        </div>
    </div>
    <script>
    // 获取元素
    var box1 = document.getElementById('box1');
    var box2 = document.getElementById('box2');
    var box3 = document.getElementById('box3');



    // 阻止默认行为
    // box3.addEventListener('click', function(e) {
    //     // 阻止默认行为
    //     e.preventDefault();

    //     console.log('box3');
    // })
    // box3.attachEvent('onclick', function(e) {
    //     // 阻止默认行为
    //     e.returnValue = false;
    //     console.log('box3', e.stopPropagation)
    // })

    // box1.onclick = function() {
    //     console.log('box1');
    // }

    // box3.onclick = function(e) {
    //     // 阻止默认行为
    //     // e.preventDefault();
    //     // // 阻止冒泡
    //     // e.stopPropagation();
    //     console.log('onclick');
    //     // 阻止默认行为
    //     return false;
    // }

    // dom2级事件绑定
    // // 默认绑定在冒泡阶段
    // box1.addEventListener('click', function() {
    //     console.log('box1');
    // })
    // box2.addEventListener('click', function() {
    //     console.log('box2');
    // })
    // box3.addEventListener('click', function(e) {
    //     console.log('box3');
    // })

    // // 绑定在捕获阶段
    // box1.addEventListener('click', function() {
    //     console.log('box1');
    // }, true)
    // box2.addEventListener('click', function() {
    //     console.log('box2');
    // }, true)
    // box3.addEventListener('click', function(e) {
    //     // 阻止事件冒泡
    //     e.stopPropagation();
    //     console.log('box3');
    // }, true)

    // ie
    // box1.attachEvent('onclick', function() {
    //     console.log('box1')
    // })
    // box2.attachEvent('onclick', function() {
    //     console.log('box2')
    // })
    // box3.attachEvent('onclick', function(e) {
    //     // 阻止事件冒泡
    //     e.cancelBubble = true;
    //     console.log('box3', e.stopPropagation)
    // })

    </script>
</body>
</html>
```
# JS 进阶 	第三天

## 一、事件

### 1.1 常用属性

type 获取事件的类型。

target 返回触发此事件的元素（事件的目标节点，IE：srcElement）。

currentTarget 返回其事件监听器触发该事件的元素。和this差不多。

timeStamp 返回事件生成的日期和时间。
举例：div1包含div2，div1绑定click事件，
```js
bindEvent(box1, 'click', function(e) {
    console.log(e.type);
    console.log(e.target);
    console.log(e.currentTarget);
})
```
这时点击div2，可以看到1、click，2、div2，因为是div2触发事件的元素。3、div1，其实就是this




## 二、DOM属性

### 2.1 快捷尺寸

clientWidth clientHeight

 获取的值包含的是content + padding

offsetWidth offsetHeight

 获取的值包含的是content + padding + border

clientLeft clientTop

 获取的值这两个属性标记的是元素边框的厚度

```js
// 获取元素
// content + padding
console.log('client', box2.clientWidth, box2.clientHeight);
// content + padding + border
console.log('offset', box2.offsetWidth, box2.offsetHeight);
// border
console.log('border', box2.clientLeft, box2.clientTop);
```



### 2.2 jQuery中的快捷尺寸

获取content尺寸

 width()，height()

获取content + padding尺寸

 innerWidth()，innerHeight()

获取content + padding + border尺寸

 outerWidth()，outerHeight()

获取content + padding + border + margin尺寸

 outerWidth(true)，outerHeight(true)

```js
// 获取元素
var box = $('#box2');
// content
console.log('content', box.width(), box.height());
// content + padding
console.log('client', box.innerWidth(), box.innerHeight());
// content + padding + border
console.log('offset', box.outerWidth(), box.outerHeight());
// margin
console.log('margin', box.outerWidth(true), box.outerHeight(true));
```



### 2.3 定位父元素与定位值

定位父元素

 	可以理解为子绝父相中的“父”。但是不一定是该元素的parentNode，可以通过offsetParent获取
    举例：box1包含box2包含box3，box1相对定位，box3绝对定位，那么offsetParent获取的是box1，相对于谁就是谁。

定位值

 	元素的定位值也是经常要使用的值，因此，在DOM中提供了相应的快捷方式

​	 dom.offsetLeft: 距离自己定位父元素的左边的距离

​	 dom.offsetTop: 距离自己定位父元素的上边的距离

总结：该属性存在兼容性的问题：

​	 在高级浏览器中，从子元素的边框外到定位父元素的边框内

​	 在IE中，从子元素的边框外到定位父元素的边框外 （多算了一条父元素的边框）

### 2.4 jQuery中的定位值

使用方式：$(dom).position()

 通过该方法可以获取元素的定位值，其中包含的是元素的定位left值，还有定位top值，
     var pos = $('.box').position();
     pos.left:左定位
     pos.top:上定位
最终得到一个对象

元素到页面之间的距离：$(dom).offset():

 返回的是一个对象， 对象中包含了元素到**页面**之间的top值和left值

position相对于定位的父元素，offset为相对于页面，最左上角那一点，不是body。

```js
// 获取定位元素在页面中的位置，不用jquery实现jquery中的offset方法
function offset(dom) {
    // console.log(dom.offsetParent, dom.parentNode)
    // 获取当前元素的定位值
    var result = {
        left: dom.offsetLeft,
        top: dom.offsetTop
    };
    // console.log(result);
    // 依次遍历每一个元素的定位元素，直到body，往上窜。
    while (dom !== document.body) {
        // 获取当前元素的定位元素
        dom = dom.offsetParent;
        // 累加结果
        // 在高级浏览器下，offsetLeft不包括边框,.clientLeft表示一个元素的额左边框的宽度。.clientTop是一个元素上边框的宽度
        result.left += dom.offsetLeft + dom.clientLeft;
        result.top += dom.offsetTop + dom.clientTop;
        // 还可以在这里做兼容性适配  navigator.userAgent
    }
    // 返回结果
    return result;
}
// 测试
console.log(offset(box3));
```



### 2.5 页面卷曲值

获取页面的卷动值

 当页面的高度超过了视口的高度会出现滚动条，页面的卷动值指的是上面看不到的部分（被卷起来了）

 在旧版本chrome中，获取页面卷动值的: document.body.scrollTop

 新版的chrome、火狐、IE, 获取页面卷动值的方式： document.documentElement.scrollTop
  
 可以通过BOM元素window获取 window.scrollx和window.scrolly，有没有window.都行

 获取视口的宽度： document.documentElement.clientWidth

 获取视口的高度： document.documentElement.clientHeight



### 2.6 卷曲事件

onscroll事件

 页面中视口的高度是一定的，当页面的高度大于了视口高度的时候将会出现滚动条，此时，滚动鼠标滚轮的时候会改变滚动条的位置，此时该事件将会触发。

 触发该事件的条件：改变页面的卷动值

 触发该事件的方式有很多：滚动鼠标滚轮， 按下键盘上的空格键 ， 按下键盘上的上下箭头， 键盘上的PgUp、PgDn

注意：scroll事件是一个高频事件。

```js
// 绑定滚动事件
$(window).scroll(function() {
    // 获取横向和纵向卷曲值
    console.log(1111, $(window).scrollTop(), $(window).scrollLeft());
    console.log(222, $(document).scrollTop(), $(document).scrollLeft());
})
// 获取视口宽高
console.log($(window).width(), $(window).height());
// 获取页面宽高
console.log($(document).width(), $(document).height());
```






# JS进阶	第四天

## 一、事件

### 1.1 滚轮事件

事件名称：onmousewheel

 该事件存在兼容性的问题，火狐不支持onmousewheel ，支持DOMMouseScroll事件

事件对象

 在鼠标点击事件中，我们关心的是鼠标的位置；在鼠标滚轮事件中，我们关心的是滚轮的方向

所以要在函数库里更改bindEvent事件了，还有移除事件。
总结：

 在非火狐中（chrome、IE），指示鼠标滚轮方向的属性: e.wheelDelta

 如果是往下滚动：-120的倍数；如果是往上滚动： 120的倍数

 在火狐中，指示鼠标滚轮方向的属性: e.detail

 如果是往下滚动： 3的倍数；如果是往上滚动： -3的倍数

```js
// 监听页面滚动
document.addEventListener('mousewheel', function(e) {
    console.log(e.wheelDelta);
})
// 火狐
document.addEventListener('DOMMouseScroll', function(e) {
    console.log(111, e.detail, e);
})

// 绑定事件
bindEvent(document, 'mousewheel', function() {
    console.log('11111111');
})
```



### 12 键盘事件

onkeydown：键盘按下
    e.key:键盘按下的是啥键

onkeyup：键盘弹起

onkeypress：字符输入

使用键盘事件

 1 可以对document对象使用键盘事件

 2 可以对输入框使用键盘事件

 3 设置了tabindex属性的元素，可以使用键盘事件

 tabindex用来设置按下tab键时，元素获取焦点的顺序。可以通过focus（获取焦点）与blur（失去焦点）处理焦点事件

在键盘事件中，可以通过事件对象的keyCode属性获取键码，key表示字符 

下面例子中，如果按了个k，会先打印'keydown'，'onkeypress'，'onkeyup'
先按下，然后输入字符，然后弹起
但是如果按了个control，会打印'keydown'，'onkeyup，因为control不是输入字符。
document可以绑定，
```js
// 监听键盘事件
// 按下
document.onkeydown = function(e) {
    console.log('keydown', e.keyCode, e.key)
}
// 弹起
document.onkeyup = function() {
    console.log('onkeyup')
}
// 输入字符
document.onkeypress = function() {
    console.log('onkeypress')
}
```



### 1.3 tabindex

该属性是html中的标准属性

页面中的元素有很多，此时当用户失去鼠标之后，可以通过键盘上的tab键来切换获取元素，当给元素添加tabIndex属性的时候，它的属性值就决定了当用户按下tab键的时候，获取元素焦点的顺序
从小到大依次获取焦点，不仅可以给输入框，普通元素同样可以设置tabindex

按下tab键是按照tabIndexs属性值的顺序来获取

如果按下shift + tab 按照逆序的顺序来获取

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <input type="text" tabindex="6">
    <input id="inp1" type="text" tabindex="5">
    <input type="text" tabindex="7">
    <ul>
        <li tabindex="1">1</li>
        <li tabindex="2" id="li2">2</li>
        <li tabindex="3">3</li>
        <li tabindex="4">4</li>
    </ul>
    <script>
    // 捕获焦点
    inp1.onfocus = function() {
        console.log('inp1 focus')
    }
    // 失去焦点
    inp1.onblur = function() {
        console.log('inp1 blur');
    }
    // 设置tabindex顺序的元素，也可以捕获焦点，失去焦点
    li2.onfocus = function() {
        console.log('li2 focus')
    }
    // 失去焦点
    li2.onblur = function() {
        console.log('li2 blur');
    }
    </script>
</body>
</html>
```
绑定键盘事件
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <div tabindex="1">hello</div>
    <!-- 如果div不设置tabindex，是无法触发键盘事件的 -->
    <input type="text">
    <script>
    // 绑定键盘事件
    // document
    document.onkeydown = function() {
        console.log('document key down');
    }
    // 输入框
    // getElementById, getElementsByTagName
    // querySelector与querySelectAll
    document.getElementsByTagName('div')[0].onkeydown = function() {
        console.log('div key down');
    }
    document.getElementsByTagName('input')[0].onkeydown = function() {
        console.log('input key down');//因为document也绑定了，所以事件也会冒泡到document
    }
    </script>
</body>
</html>
```
querySelector与querySelectorAll
querySelector('css3选择器')，只能获取第一个
querySelectorAll('css3选择器')，全能选到，比如全选div标签
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <div>1111</div>
    <input type="text">
    <input type="checkbox">
    <div class="demo">demo</div>
    <div class="demo">demo</div>
    <script>
    // 为了可以像css3那样获取元素，提供了querySelector与querySelectorAll方法
    // console.log(document.querySelector('div'))
    // console.log(document.querySelectorAll('div'))
    // console.log(document.querySelectorAll('.demo'))
    // console.log(document.querySelectorAll('input[type=checkbox]'))

    // 区别
    // 动态的
    var div1 = document.getElementsByTagName('div');
    // 静态的
    var div2 = document.querySelectorAll('div');
    // 向页面中插入div
    var div = document.createElement('div');
    div.innerHTML = 'new div';
    document.body.appendChild(div);
    console.log(div1, div2);
    //这时div1会显示新插入的div，但是div2不会显示新插入进来的div，也就是说document.getElementsByTagName是动态的，.querySelectorAll是静态的。
    </script>
</body>
</html>
```