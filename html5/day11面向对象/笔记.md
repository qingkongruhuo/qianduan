# JS 进阶	第五天

## 一、面向对象编程

### 1.1 面向对象

我们之前写的代码都是使用面向过程的方式

**面向过程**

 var name = '老王’; 

 var age = 18; 

 var sex = ‘男’; 

 var length = 180; 

 **面向对象**

 var person = {

​		name: '老王',

​		age: 20,

​		sex: "男",

​		length: 180

  }  

 也就是说，面向对象是代码书写的另一种方式

优点：便捷,复用性强，可以防止创建多个变量造成的变量被污染
ps：通过一个函数返回一个对象是工厂模式。

### 1.2 构造函数

构造函数与普通函数在定义方式上没有不同， 只不过构造函数的首字母要大写，此要求非语法要求。通过构造函数可以创建一类对象，该构造函数称为类，创建的对象也称之为实例化对象。
构造函数必须使用new 关键字进行调用

 目的： 普通函数： 实现某一种功能； 
       构造函数： 为了创建对象

 调用方式: 普通函数： 直接调用； 
          构造函数： 使用new 进行调用

构造函数执行时候的四个步骤

 1 开辟一个新的内存空间

 2 改变this指向，**构造函数中this被改变了指向实例对象**

 3 执行函数中的代码，为this赋值

 4 返回this，即该实例对象。
    如果构造函数不返回this，返回一些值类型的数据，完全不影响创建对象，但是如果返回的是一个对象，那么就会返回该对象。
function 类名 (属性1,属性2,...){
    this.属性1 = 属性1;
    this.属性2 = 属性2;
    return this
}
var obj = new 类名(值1,值2,值3);

```js
    //普通函数
    function person() {
        console.log(this)
    }
    preson();//打印window
    //构造函数
    function Person() {
        console.log(this);
    }
    new Person();//打印Person，构造函数中this被改变了指向实例对象
```

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
    // 定义构造函数： 构造函数与普通函数一样，只不过通常将首字母大写
    // // 人的构造函数
    // function Person() {}
    // // 狗的构造函数
    // function Dog() {}
    // // 通过构造函数创建对象
    // var p = new Person();
    // var d = new Dog();
    // console.log(p, d);
    /**
     * 概念 
     * 类：通过构造函数可以创建一类对象，该构造函数就称之为类
     * 实例化对象：创建的对象称之为该类的实例化对象
     **/

    // 普通函数与构造函数中的this
    // 普通函数
    // function person() {
    //     console.log(this)
    // }
    // var result = person();
    // console.log(result);
    // 构造函数
    // function Person() {
    //     console.log(this);
    // }
    // new Person();

    /****
     * 构造函数的四步
     *  1 开辟空间
     *  2 更改this指向，指向实例对象
     *  3 执行构造函数语句，为this赋值
     *  4 返回该实例化对象
     * ***/ 
    function Person(name, sex, age) {
        // 为实例化对象赋值
        this.name = name;
        this.sex = sex;
        this.age = age;
        // 返回其它数据，
        // 如果是值类型没有影响，不会影响对象创建。
        // return 100
        // return 'hello'
        // return true
        // return undefined
        // return null
        // 数据类型：数字，字符串，布尔值，undefined, null, 对象
        // 返回对象，实例对象会被替代！
        // return { color: 'red' }
        // return [1, 2, 3]
        // return function demo() {}
        // 可以返回this
        return this;
    }
    // 实例化
    var p = new Person('小白', '男', 20);
    console.log(p);
    </script>
</body>
</html>
```
**数组塌陷**
下面例子中，遍历的时候删除6这个元素，会发现后面的元素全部向前进了一位，这就是数组塌陷。
当遇到问题需要避免塌陷的时候，可以从后往前遍历。因为删除的元素只会影响后面的，
如果遍历一半需要删除元素，因为影响的是后面的，但是后面的已经遍历完了，所以无所谓辣。
```js
var arr = [0,1,2,3,4,5,6,7,8,9];
for(var i = 0;i<arr.length;i++){
    if(i==6){
        arr.splice(i,1);
    }
    console.log(i,arr,arr[i]);
}
```


### 1.3 原型

原型是每一个**函数**天生可以调用的属性，它的值是一个对象，对象中有constructor属性表示构造函数本身

在构造函数中，可以把函数作为属性添加到对象中，但是，比如创建了两个实例化对象o1和o2，o1.fun===o2.fun会出现false，虽然它们的函数都是构造函数里写的，是一模一样的，但是js会让每个实例单独存储一份，都是不相同的。但是没必要让它们不同。

```js
//解决方案1：把函数放到构造函数外,缺点：当函数多起来，会污染全局作用域。
function Person(name,age){
    this.name = name;
    this.age = age;
    this.getName = getName;
    this.getAge = getAge;
}
function getName(){};
function getAge(){};
```
```js
//解决方案2：把函数对象中存储。缺点：还是要在全局作用域放一个元素。
function Person(name,age){
    this.name = name;
    this.age = age;
    this.getName = obj.getName;
    this.getAge = obj.getAge;
}
var obj = {
    getName(){},
    getAge(){}
}
```

```js
//解决方案3：将这个对象放在Person类中。缺点：构造函数内的名和构造函数名耦合在一起，想改一个都得改。
function Person(name,age){
    this.name = name;
    this.age = age;
    this.getName = Person.obj.getName;
    this.getAge = Person.obj.getAge;
}
Person.obj = {
    getName(){},
    getAge(){}
}
```
为了解决这个问题，js为构造函数提供了原型对象，prototype，这是函数天生存在的（对普通函数毫无意义），它是一个对象，可以存储数据和方法，但是对于构造函数来说，每一个构造函数的实例化对象都可以访问原型中的属性和方法，每一个构造函数都有一个隐含的属性指向该原型对象，通过_proto_属性来访问原型对象。
原型对象是一个公共区域，所有的实例化都可以直接访问。
在创建构造函数的时候，我们可以将所有的方法都写在原型对象中，这样方法就不会污染全局作用域，每一个实例化对象都可以访问，每一个实例化访问一个属性或者方法的时候，会从自身开始查找，有的话会使用自身的，没有的话会从原型中查找。

 作用：实例共享属性和方法

 特点：每一个实例化对象天生可以访问类原型中的所有内容

特点    
    1、定义了同名方法，实例化对象优先使用构造函数内部的函数而不是原型中的。
    2、原型上有constructor属性，代表构造函数。
        console.log(p1.constructor);//会打印构造函数
    3、使用forin循环可以将原型数据遍历出来
        forin循环不仅可以遍历出构造函数里面的属性，还可以遍历出原型中添加的属性。只不过原型中遍历出来的属性用hasOwnProperty返回值为false

拓展

  **instanceof**

 该关键字用于判定某一个对象是否是某一个构造函数的实例

 会查询整个原型链。
  
  **原型链：**
 对象有原型对象，原型对象也是对象，所以原型对象也有原型对象。数据在查找的时候：会在当前实例对象上查找，当前实例对象没有，去原型对象上查找，原型对象没有，会去原型对象的原型对象上查找 ，，， 一致查找到原型对象的终点：null， 如果此时还没有找到，就说明该数据是不存在的。这个查找过程就是原型链，与作用域查找数据类似。
    比如hasOwnProperty，p1的构造函数中没有这个方法，就到原型对象上查找，原型对象上没有，就到原型对象的原型对象(Object.propotype)上查找，找到了hasOwnProperty，调用。
 console.log(p1.__proto__);   返回的是Person构造函数的原型对象。
 console.log(p1.__proto__.__proto__);返回obj对象的原型对象，到头了，在往下找就是null了。
 console.log(Person.__proto__); 因为构造函数也是函数，而函数也是对象。返回的就是函数的构造函数的原型对象了。
 **hasOwnProperty:**

 该方法检测某个对象身上是否包含了指定的属性
    使用方法：Obj.hasOwnProperty(属性名)，返回值为true和false
    true：构造函数中有这个属性
    false：构造函数中没这个属性(原型上添加的也会返回false)。


```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
    function Person(name, sex, age) {
        this.name = name;
        this.sex = sex;
        this.age = age;
        // 1 定义了同名方法，Person类内部的会先被实例化对象查找。即优先使用构造函数内部的而不是原型中的。
        this.getName = function() {
            console.log(this.name);
        }
    }
    // 为原型对象添加属性，让实例共享
    Person.prototype.getName = function() {
        console.log('姓名: ', this.name);
    }
    Person.prototype.getSex = function() {}
    Person.prototype.getAge = function() {}
    // 原型可以存储属性数据
    Person.prototype.msg = 'hello';
    // 创建人
    var p1 = new Person('小白', '男', 20);
    // 2 原型上有constructor属性，代表构造函数。
    console.log(p1);
    // console.log(p1.constructor);
    // // 使用方法
    // p1.getName();

    // 3 for in循环，可以将原型数据遍历处理
    for (var key in p1) {
        // hasOwnProperty  如果是自身的返回true，如果是原型的返回false
        // console.log(key, p1[key]);
        // console.log(p1.hasOwnProperty(key), key);
        // 查看自身属性
        if (p1.hasOwnProperty(key)) {
            console.log(key, p1[key]);
        }
    }
    // 判断p1是不是persion实例
    console.log(p1 instanceof Person);//是
    // 对象：Object
    console.log(p1 instanceof Object);//是
    // 数组：Array
    console.log(p1 instanceof Array);//不是
    /** 
     * 原型链：
     *      对象有原型对象，原型对象也是对象，所以原型对象也有原型对象
     *      数据在查找的时候：会在当前实例对象上查找，当前实例对象没有，去原型对象上查找，原型对象没有，会去原型对象的原型对象上查找 ，，， 一致查找到原型对象的终点：null， 如果此时还没有找到，就说明该数据是不存在的。这个查找过程就是原型链，与作用域查找数据类似
     * 
     * 
     * ***/
    // 查看原型对象
    // 双下划线都是内置的属性，不建议我们访问
    // 构造也是对象，因此他的原型对象就是函数
    console.log(Person.__proto__);
    // p1也是对象，原型对象就是Person构造函数的原型对象
    console.log(p1.__proto__, p1.__proto__.hasOwnProperty('hasOwnProperty'));
    console.log(p1.__proto__.__proto__, p1.__proto__.__proto__.hasOwnProperty('hasOwnProperty'));
    console.log(p1.__proto__.__proto__.__proto__);
    

    // 作用域
    function a() {
        var id = 10;
        function b() {
            var id = 20;
            // 当前作用域下没有id数据，向外层作用域查找，外面有则使用。
            console.log(id)
        }
        b();
    }
    a();
    </script>
</body>
</html>
```

# JS进阶	第六天

## 一、面向对象

### 1.1 安全类
```js
    function People(name, age) {
        console.log(this);
        this.name = name;
        this.age = age;
    }
    // 创建对象
    var p1 = new People('张三', 20);
    // 没有创建出对象， 把构造函数当作普通函数去使用了
    // this赋值被添加到全局了（污染了全局作用域）
    var p2 = People('李四', 30);
    console.log(p1, p2);//p1为People类实例对象，p2为undefined（当函数去调用了），p1this指向people实例对象，p2this指向window！这时给people当普通函数传递参数，this.age其实被挂在到全局了会污染全局
    console.log(age);

    var age = 50;
```

无论外部如何调用该类，都会返回一个类的实例化对象** 把构造函数既当成构造函数用，又想当成工厂方法用**

 在构造函数中，判断this的指向，从而决定代码如何执行

 如果this是该类的实例，正常创建对象

 否则说明用户将构造函数当作普通函数来执行，我们要在内部重新实例化并返回结果
```js
// 安全类，在内部判断this是否是该类的实例，是的话，直接实例，不是的话重新实例并返回
    function People(name, age) {
        // 判断this是不是People类的实例化对象
        if (this instanceof People) {
            // 直接赋值
            this.name = name;
            this.age = age;
        } else {
            // 重新实例化
            return new People(name, age);
        }
    }
```

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
    // 一切数据都可以看成是对象，是对象都有与之对应的类
    // 例如
        // 数组对应的类是Array，
        // 对象对一个的类是Object

    // 创建数组的三种方式
    // 字面量
    var arr = [1, 2, 3];
    // 构造函数
    var arr2 = new Array(3, 4, 5);
    // 工厂方法
    var arr3 = Array(6, 7, 8);

    // 数组构造函数式和工厂方法式的小问题（了解）：对参数做了重载（传递的参数个数的不同，以及类型的不同，得到的结果不同（执行的逻辑不同））
    // console.log(new Array(3), new Array('3'), new Array(2, 3));
    //第一个打印出的结果代表数组长度3，第二个长度1，3为字符串，第三个长度2，两个元素2和3，下面的同理。
    // console.log(Array(3), Array('3'), Array(2, 3));
    // console.log(arr, arr2, arr3);
    
    // 创建对象的三种方式
    // 字面量
    var obj1 = { color: 'red' };
    // 构造函数式
    var obj2 = new Object({ color: 'green' })
    // 工厂方法式
    var obj3 = Object({ color: 'pink' })
    // console.log(obj1, obj2, obj3);


    // var age = 50;
    // 创建类
    function People(name, age) {
        console.log(this);
        this.name = name;
        this.age = age;
    }
    // 创建对象
    var p1 = new People('张三', 20);
    // 没有创建出对象， 把构造函数当作普通函数去使用了
    // this赋值被添加到全局了（污染了全局作用域）
    var p2 = People('李四', 30);
    console.log(p1, p2);//p1为People类实例对象，p2为undefined（当函数去调用了），p1this指向people实例对象，p2this指向window！这时给people当普通函数传递参数，this.age其实被挂在到全局了
    console.log(age);

    var age = 50;
    // 安全类，在内部判断this是否是该类的实例，是的话，直接实例，不是的话重新实例并返回
    function People(name, age) {
        // 判断this是不是People类的实例化对象
        if (this instanceof People) {
            // 直接赋值
            this.name = name;
            this.age = age;
        } else {
            // 重新实例化
            return new People(name, age);
        }
    }
    // 创建对象
    var p1 = new People('张三', 20);
    var p2 = People('李四', 30);
    console.log(p1, p2);
    console.log(age);
   </script>
</body>
</html>
```



### 1.2 内置构造函数
（类包括构造函数和原型，以后就把类说成构造函数了，）
内置的构造函数：不是我们创建的，是js语言天生存在的，比如new Object();

内置构造函数的分类：

 ECMAScript核心语法也支持一些内置构造函数:

 Object Array( new Array();) Function String Number Boolean RegExp Error Date

### 1.3 Function

创建函数的三种方式：函数表达式，函数定义式

该内置构造函数用于创建函数

 使用方式：new Function(arg1, arg2, ......, body);

​	 可以接收多个参数，除了最后一个参数是函数体，其它的都是形参
举例：
```js
    new Function('a','b','console.log(a+b);return a+b');
```
**把函数体写在字符串里，可读性很差，所以不常见**

 特点：通过new Function得到的函数，通过函数.name属性得到的是anonymous

 而通过函数表达式和函数声明式，打点调用name属性得到的是函数名称

拓展：

​	 **函数.length 得到的是形参的个数**

​	 **arguments.length 得到的是实参的个数**

扩展
[让字符值作为语句去执行的第二种方式
    // eval('console.log("hello ickt")')
    eval('var num = 100');
     * new Function与eval的区别：
     *      new Function定义的变量式在函数体内部定义的，是局部变量
     *      eval字符串中定义的变量，由于在全局作用域中执行，因此会存储在全局，污染全局作用域。
]
### 1.4 RegExp

该内置构造函数用于创建正则表达式

使用方式：new RegExp(reg, letter);

 接收两个参数：

​	 第一个参数是正则表达式的表达体， 字符串

​	 第二个参数是正则表达式的修饰符，i、g、m

 注意：因为字符串中也有转义，所以需要多转义一次

```js
var reg1 = /^\w{2,6}$/i;
var reg2 = new RegExp('^\\w{2,6}$',i);//单斜杆要转义。
```
### Error
创建错误
    var err = new Error('提示错误的内容');
抛出错误:一旦抛出错误，程序会被打断 **慎重使用抛出错误**
    throw err;
Error也是个安全类，加不加new都是一样的，但是在工作中一般都加new

### Date
也是个安全类，加不加new都一样

var d = new Date('2020-7-10');日期对象,如果不传参数就是现在的时间

var d2 = Date();日期字符串

日期对象有很多方法,下面例子中显示

时间戳：计算机有个诞生的日子，1970 0 0 0，东八区，1970 8 0 0 
      时间戳就是距离这个时间过了多少秒

### 1.5 其它内置构造函数

**String**
    
​	 该内置构造函数是string值类型的对应包装类型

​	 字符串底层其实是构造函数创建出来的，这也就说明了为什么一个字符串可以调用方法。（比如字符串在调用.charAt()时，会自动封装成String，然后调用方法）

**Number**

​	 是number值类型的对应包装类型。转为对应的包装类型
    number底层其实是构造函数创建出来的，这也就说明了为什么一个字符串可以调用方
法。
**Number和String的工厂方法**
```js
var str = new String(100);//打印的话，出现String实例对象
var str2 = new String(100);//打印的话，出现'100'（String原始类型string）
var num1 = new Number('100');//Number实例对象
var num2 = Number('100');//100（Number原始类型number）

```
所以Number和String的工厂方法可以做显式的数据类型转化，string与number互转
（隐式转化：字符串+为数字，数字+''为字符串，!!字符串为布尔）
**Boolean**

​	 是Boolean值类型的对应包装类型。转为对应的包装类型
```js
var boo1 = new Boolean(100);
var boo2 = Boolean(100);
```

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
    // 内置的构造函数Object  Array  Function  String  Number  Boolean  RegExp  Error  Date 
    // 内置的构造函数：不是我们创建的，是js语言天生存在的，例如 Image
    // 创建图片
    var img = new Image();
    // console.log(img);

    // 数组
    // console.log(new Array(10, 20));
    // 对象
    // console.log(new Object({ num: 100 }));

    // 创建函数的三种方式
    // 函数定义式
    function demo() {
        console.log('demo');
    }
    // 函数表达式
    var demo2 = function() {
        console.log('demo2');
    }
    // 构造函数式；
    // 最后一个参数表示函数体，前面的参数表示函数的参数
    // var demo3 = new Function('a', 'b', 'console.log(a + b)');
    // 设置返回值
    var demo3 = new Function('a', 'b', 'var num2 = 200; console.log("inner", num2); return a * b');
    // 让字符值作为语句去执行的第二种方式
    // eval('console.log("hello ickt")')
    eval('var num = 100');
    /***
     * new Function与eval的区别：
     *      new Function定义的变量式在函数体内部定义的，是局部变量
     *      eval字符串中定义的变量，由于在全局作用域中执行，因此会存储在全局，污染全局作用域。
     * ****/ 
    // console.log(num, num2);
    // console.log(num);
    // demo();
    // demo2();
    // var result = demo3(10, 20);
    // console.log(result);
    // console.log(demo3);

    // 对字符串使用方法
    // console.log(typeof 'abcdefg')
    // var arr = 'abcdefg'.split('');
    // console.log(arr);
    // 内部运行
    // var str = new String('abcdefg')
    // // 对象实例，可以调用原型上的属性和方法
    // var arr = str.split('')
    // console.log(arr)
    // console.log(String.prototype);

    // 数组
    // var num = 100;
    // // 保留两位小数
    // console.log(num.toFixed(2));
    // 内部运行（后台原型）
    // var num = new Number(100);
    // console.log(num.toFixed(2));
    // console.log(Number.prototype);

    // 字符串和数字当作工厂方法去使用：不是创建对象实例，而是包装对象（类型的转换）
    // var str = new String(100)
    // var str2 = String(100)
    // console.log(str, str2);
    // var num1 = new Number('100');
    // var num2 = Number(100)
    // console.log(num1, num2);
    // 工作中，我们常常使用String与Number工厂方法，来实现显性的数据类型转换，
    // 隐形数据类型转换     转字符串 + ''       转数字 + */%...     转布尔值  !!

    // 创建布尔值
    // 实例
    // var bool = new Boolean(100);
    // // 包装：显性转换
    // var bool2 = Boolean(100);
    // console.log(bool, bool2);
    // console.log(Boolean.prototype);

    // 创建正则
    // 正则字面量（常用）
    // var reg1 = /^\w{2,6}$/i;
    // // 构造函数式（常用）
    // // 第一个参数表示正则内容，第二个参数表示正则修饰符
    // /**
    //  * 注意：第一个参数中，\要转移一下。
    //  * ***/ 
    // var reg2 = new RegExp('^\\w{2,6}$', 'i')
    // // 工厂方法式与构造函数式是一样的（安全类）
    // var reg3 = RegExp('^\\w{2,6}$', 'i')
    // console.log(reg1, reg2, reg3);

    // 创建错误
    // var err = new Error('这是一个错误');
    // console.log(err);
    // console.log(abc);
    // 抛出错误
    // throw new Error('抛出了一个错误')
    // 一旦抛出错误，程序将终止执行
    // function demo() {
    //     console.log('before')
    //     throw new Error('出现了错误')
    //     console.log('after')
    // }
    // // demo();
    // // Error也是一个安全类 new Error更常用。
    // console.log(new Error('这是一个错误'))
    // console.log(Error('这是一个错误'))

    // 日期
    // 日期对象
    // var d = new Date();
    // 参数是表示日期的字符串
    var d = new Date('2020-7-5');
    // 日期字符串
    var d2 = Date();
    // console.log(111, d, d2);
    // console.log(Date.prototype);
    /****
     * 日期 
     *      获取年      getFullYear
     *      获取月      getMonth        注意：从0开始计数
     *      获取日      getDate
     *      获取星期    getDay          注意：从0开始计数， 星期日是0，星期一是1
     *      获取时      getHours
     *      获取分      getMinutes
     *      获取秒      getSeconds
     *      获取时间戳  getTime          简便方法： 在日期对象前，写+
     *      将get改成set就是用来修改这些数据的方法
     *      Date        参数还可以传递一个表示日期的字符串或者是时间错
     ******/ 
    console.log(d.getFullYear())
    console.log(d.getMonth())//注意：从0开始计数
    console.log(d.getDate())
    console.log(d.getDay())
    console.log(d.getHours())
    console.log(d.getMinutes())
    console.log(d.getSeconds())
    console.log(d.getTime())
    console.log(+d)
    console.log(new Date(0));
    </script>
</body>
</html>
```

### 原生对象和原型链
instanceOf会遍历整个原型链，直到找到了目标constructor，输出true，到根了也没找到，输出false
```js

    // 定义数组和对象
    var arr = []
    var obj = {};
    console.log(obj instanceof Object);
    // instanceof会遍历整个原型链，判断consctructor,arr原型是Array(0)，构造函数时Array()，不是，继续找原型的原型（原型对象也是对象）Object，构造函数Object(),一看和instanceOf后面的一样，输出true
    console.log(arr instanceof Array);
    console.log(arr instanceof Object);
    console.log(arr);
    // 报错
    // console.log(arr instanceof null);
    // 构造函数
    console.log('constructor');
    // console.log(arr.constructor === Array);//true
    // console.log(arr.constructor === Object);//false，因为找到了constructor就不会再往下找了
    // console.log(obj.constructor === Object);
    // 构造函数时函数，因此是Function实例
    console.log(arr.constructor instanceof Function);//true，所有函数都是Function实例
    console.log(arr.constructor instanceof Object);//true，Function继承Object
    console.log(arr.constructor);//Array()
    console.log(arr.constructor.constructor);//Function()
    console.log(arr.constructor.constructor.__proto__);//函数的原型f()
    console.log(arr.constructor.constructor.constructor);
    //任何对象的constructor都是函数，函数的constructor也是函数，套娃
    console.log(arr.constructor.constructor.constructor.constructor);
```


### 1.6 继承

继承： 指的是子类继承父类的属性和方法。

继承方式： 

 1 类式继承 为了把父类的方法给到子类，把父类的实例对象作为子类的原型
```js
// 定义类
    function People(name, age, sex) {
        // 存储属性
        this.name = name;
        this.age = age;
        this.sex = sex;
    }
    // 行为方法
    People.prototype.getName = function() {
        console.log('我是' + this.name);
    }
    People.prototype.getAge = function() {
        console.log('我今年' + this.age + '岁');
    }
    People.prototype.getSex = function() {
        console.log('我是' + this.sex + '人');
    }
    // 学生类
    function Student(name, age, sex, grade) {
        // 存储属性
        this.name = name;
        this.age = age;
        this.sex = sex;
        this.grade = grade;
    }
    /****
     * 类式继承（原型式继承）
     *  由于父类的实例对象拥有父类原型属性和方法，因此我们可以用父类实例对象为子类的原型赋值,可以重写父类的方法。
     * 问题
     *  1 子类原型对象上出现了父类构造函数中添加的属性和方法，是多余的，是错误的（子类上明明都有）
     *  2 多执行了一次父类的构造函数，浪费资源
     *  3 constuctor属性没了，指向错误。原因：构造函数的原型上面有constructor属性表示构造方法，但是把子类的原型被赋值成父类的实例，实例对象是没constructor的，只有原型才有，所以constructor没了。
     *    解决：把子类的原型（父类的实例）加上constructor属性，且绑定子类的构造方法。
     *  4 无法复用构造函数中，存储属性的逻辑
     * *****/ 
    Student.prototype = new People();//父类实例作为子类的原型
    
    // 更正原型上的构造函数
    Student.prototype.constructor = Student;

    // 重写方法。
    Student.prototype.getSex = function() {
        console.log('我是' + this.sex + '孩子');
    }
    // 创建对象
    var p1 = new People('老李', 20, '男');
    var s1 = new Student('小白', 10, '男', 5);
    console.log(s1, p1);
    p1.getName();
    s1.getName();
    p1.getAge();
    s1.getAge();
    p1.getSex();
    s1.getSex();
    console.log(p1.getName === s1.getName);
    console.log(p1.getAge === s1.getAge);
    // 子类的实例对象应该继承子类
    console.log(s1 instanceof Student);
```

 2 构造函数式继承:利用call，将**属性**继承过来
```js
// 父类
    function People(name, age, sex) {
        // 存储属性
        this.name = name;
        this.age = age;
        this.sex = sex;
    }
    // 行为方法
    People.prototype.getName = function() {
        console.log('我是' + this.name);
    }
    People.prototype.getAge = function() {
        console.log('我今年' + this.age + '岁');
    }
    People.prototype.getSex = function() {
        console.log('我是' + this.sex + '人');
    }
    // 子类
    function Student(name, age, sex, grade) {
        // this.name = '爱创课堂-' + name;
        /**
         * 构造函数继承
         *  让父类的构造函数，在子类对象(作用域)上执行，并传递子类的参数
         * 问题
         *  无法复用原型对象上的方法
         * 语法：obj1.call(obj2[,param1,param2,...])
           定义：用obj2对象来代替obj1，调用obj1的方法。即将obj1应用到obj2上。
         * **/
        People.call(this, name, age, sex)
        // 存储属性
        this.grade = grade;
        // 我们还可以在继承后，重写属性（如果在继承前，重写属性，会被覆盖）
        this.name = '爱创课堂-' + name;
    }
```

 3 组合式继承：就是构造函数式继承+类式集成
```js
// 定义类
    function People(name, age, sex) {
        // 存储属性
        this.name = name;
        this.age = age;
        this.sex = sex;
    }
    // 行为方法
    People.prototype.getName = function() {
        console.log('我是' + this.name);
    }
    People.prototype.getAge = function() {
        console.log('我今年' + this.age + '岁');
    }
    People.prototype.getSex = function() {
        console.log('我是' + this.sex + '人');
    }
    /****
     * 组合式的继承就是综合使用构造函数式继承以及类是继承
     *  通过构造函数式继承复用构造函数中，存储属性的逻辑
     *  通过类式继承复用原型上的方法
     * 问题：就是类式继承的问题。
     *  1 子类原型对象上出现了父类构造函数中添加的属性和方法，是多余的，是错误的
     *  2 多执行了一次父类的构造函数
     *  3 constuctor属性没了，指向错误
     *  4 无法复用构造函数中，存储属性的逻辑
     * ******/ 
    // 学生类
    function Student(name, age, sex, grade) {
        // 构造函数继承
        People.call(this, name, age, sex);
        // 存储属性
        this.grade = grade;
    }
    // 类式继承
    Student.prototype = new People();
    // 重写构造函数
    Student.prototype.constructor = Student;
    // 重写方法。
    Student.prototype.getSex = function() {
        console.log('我是' + this.sex + '孩子');
    }
    // 创建对象
    var p1 = new People('老李', 20, '男');
    var s1 = new Student('小白', 10, '男', 5);
    console.log(s1, p1);
    p1.getName();
    s1.getName();
    p1.getAge();
    s1.getAge();
    p1.getSex();
    s1.getSex();
    console.log(p1.getName === s1.getName);
    console.log(p1.getAge === s1.getAge);
    // 子类的实例对象应该继承子类
    console.log(s1 instanceof Student);
    // 获取错误
    console.log(s1.constructor);
```

 4 寄生式继承 :解决类式继承的问题
```js
// 定义类
    function People(name, age, sex) {
        // 存储属性
        this.name = name;
        this.age = age;
        this.sex = sex;
    }
    // 行为方法
    People.prototype.getName = function() {
        console.log('我是' + this.name);
    }
    People.prototype.getAge = function() {
        console.log('我今年' + this.age + '岁');
    }
    People.prototype.getSex = function() {
        console.log('我是' + this.sex + '人');
    }
    /****
     * 寄生式继承
     *  在一个继承方法中，创建一个寄生类，让寄生类的原型，等于父类的原型，在实例化寄生类，赋值给子类原型
     * 解决类式继承的问题：
     *      1、因为寄生类里面只写了一句改构造器指向，所以子类原型不会出现父类的属性。
     *      2、寄生类里面只有一句改构造器指向，不会消耗太多资源。
     *      3、不存在的
     *      4、同样无法复用构造函数中存储属性的逻辑。
     * 问题
     *  无法复用构造函数中存储属性的逻辑
     * ******/ 
    function inherit(child, parent) {
        // 定义寄生类
        function F() {
            //寄生类里面不写属性，这样创建实例的时候子类的原型上就没有乱七八糟的属性了。针对类式继承问题1
            // 修改构造函数
            this.constructor = child;
        }
        // 让寄生类的原型等于父类的原型
        F.prototype = parent.prototype;
        // 用寄生类实例为子类赋值，因为一个实例对象调用方法是去原型上找的，子类实例对象调用方法=>子类原型(也就是F实例对象)=>F实例对象也要到自己的原型上找=>F.prototype，也就是父类的prototype=>父类的原型有方法，//所以找到了，即子类的实例对象可以调用父类的方法。
        //好处：父类的原型和父类的实例是完全不同的俩对象，修改父类F的实例不会改变父类的原型。
        child.prototype = new F();
        // 修改构造函数，放在F寄生类里面了。
        // child.prototype.constructor = child;
        return child;
    }
    // 学生类
    function Student(name, age, sex, grade) {
        this.name = name;
        this.age = age;
        this.sex = sex;
        // 存储属性
        this.grade = grade;
    }
    // 寄生式继承
    inherit(Student, People)

    Student.prototype.getSex = function() {
        console.log('我是' + this.sex + '孩子');
    }
    // 创建对象
    var p1 = new People('老李', 20, '男');
    var s1 = new Student('小白', 10, '男', 5);
    console.log(s1, p1);
    p1.getName();
    s1.getName();
    p1.getAge();
    s1.getAge();
    p1.getSex();
    s1.getSex();
    console.log(p1.getName === s1.getName);
    console.log(p1.getAge === s1.getAge);
    // 子类的实例对象应该继承子类
    console.log(s1 instanceof Student);
    // 获取错误
    console.log(s1.constructor);
```

 5 寄生式组合继承：构造函数式(复用父类构造函数中存储属性的逻辑)+寄生式
 ES6之前兼容性最好的方式
```js
function People(name, age, sex) {
        // 存储属性
        this.name = name;
        this.age = age;
        this.sex = sex;
    }
    // 行为方法
    People.prototype.getName = function() {
        console.log('我是' + this.name);
    }
    People.prototype.getAge = function() {
        console.log('我今年' + this.age + '岁');
    }
    People.prototype.getSex = function() {
        console.log('我是' + this.sex + '人');
    }
    /****
     * 寄生组合式继承
     *  综合使用寄生式以及构造函数式的继承
     * ******/ 
    function inherit(child, parent) {
        // 定义继承类
        function F() {
            // 修改构造函数
            this.constructor = child;
        }
        // 让寄生类的原型等于父类的原型
        F.prototype = parent.prototype;
        // 用寄生类实例为子类赋值
        child.prototype = new F();
        // 修改构造函数
        // child.prototype.constructor = child;
        return child;
    }
    // 学生类
    function Student(name, age, sex, grade) {
        // 构造函数式，复用父类构造函数中，存储属性的逻辑
        People.call(this, name, age, sex);
        // 存储属性
        this.grade = grade;
    }
    // 寄生式继承
    inherit(Student, People)

    Student.prototype.getSex = function() {
        console.log('我是' + this.sex + '孩子');
    }
    // 创建对象
    var p1 = new People('老李', 20, '男');
    var s1 = new Student('小白', 10, '男', 5);
    console.log(s1, p1);
    p1.getName();
    s1.getName();
    p1.getAge();
    s1.getAge();
    p1.getSex();
    s1.getSex();
    console.log(p1.getName === s1.getName);
    console.log(p1.getAge === s1.getAge);
    // 子类的实例对象应该继承子类
    console.log(s1 instanceof Student);
    // 获取错误
    console.log(s1.constructor);
```
注意！！！！继承后给prototype添加属性一定要用点语法
Student.prototype={
    属性名:'',
    这样会把原型对象换成新的对象！之前的全没了！
}
