一、背景属性
    1、background-color 背景色
        背景色默认绘制到border以内的区域，比如border取了虚线，虚线露出来的还是背景色
    2、background-img: url("") 背景图片，双引号写路径
        但是背景图片从padding开始渲染，并从border开始平铺渲染
        解读：比如边框border有粗细，一张完整的图片从padding左上角开始渲染，但是不是一张图片可以完整渲染到
            一个盒子内，剩下空白的地方继续从图片上面重新渲染，这种渲染叫平铺渲染，同理border上面也是进行了平铺渲染
    3、background-repeat 设置北京平铺，no-repeat不重复平铺，repeat-x水平平铺，-y是垂直平铺
        注意：如果不设置平铺，那么露出来的地方还是背景色
        也就是说背景色设置和背景图片是完全不冲突的两个属性
二、背景定位
    1、background-position 用于背景定位，属性值分别表示x方向坐标 y方向坐标
    从padding开始(border以内)进行定位的（注：css中坐标轴是倒置的坐标轴，x坐标轴朝右不变，但是y坐标轴是朝下正向），
    有三种使用方式
        1、数值法：background-position: 100px 100px 向右向下各移动100
        2、特殊变量：水平方向：left right center（居中） 垂直方向 top bottom center（居中），工作中常用top center
        3、百分比数值:(盒子宽度|盒子高度+盒子padding*2-背景图片的宽度|背景图片的高度)*百分比
        4、单独设置
            background-position-x 设置水平方向
            background-position-y 设置垂直方向
    2、background-attachment 用来固定背景 
        scroll 滚动页面，位置不变，相对窗口位置变化；默认值
        fixed 滚动页面，位置变化，相对窗口位置不变
             设置了这个后，比如这个box特别长，向下滚动滚动条的时候，
             背景图片一直在这个地方！但是相对窗口位置是变化的
             而且设置了这个属性后，图片的相对位置是相对于页面的，不再是padding了

三、背景应用
    1、background是一个符合属性，可以同时设置背景颜色，背景图片，背景图片位置，背景图片平铺
        在css3中还可以设置背景图片尺寸，背景图片起始位置，背景图片截取，背景图片定位等

        设置顺序：background：背景色，背景图片，背景平铺，背景定位，背景固定
            背景图片优先于背景色，背景图片会盖住背景色
    2、应用：
        1、制作渐变背景：设置一个渐变单元，然后水平平铺设置渐变背景
            注意：linear-gradient属性可以设置渐变，但这是css3属性，低版本浏览器不支持，我们可以使用背景平铺来解决
        2、背景居中，设置banner图片，banner图片是网站导航图，让导航图居中用背景居中很容易
        
        3、伪元素设置背景：使用行内元素设置背景，改变了原有的dom结构，因为我们新增行内元素span
            为了避免插入新元素，我们可以使用伪元素，步骤：
                1、设置伪元素
                2、设置content属性，让伪元素显示
                3、设置padding撑起宽高
                4、修改字号
                5、居中对齐，设置vertical-aline:middle
                6、调整外边距
        No2.html将li图标换成图片就是这套操作

        4、seo搜索引擎优化，为了提高网站权重，我们通常将重要信息写在h1中，有时候这些重要信息是一些图片
        那么我们将图片写在h1中搜索引擎不认识，是一中错误的方式，因为搜索引擎不会解析图片中的文字
        通常我们在h1中写文字，然后背景用来显示这张图片，但是里面还有文字怎么办？（即让文字不显示）
            只需要让文字溢出容器即可
                1、text-indent让文字缩进好多字符，溢出
                2、line-height 设置行间距离超级大让文字从盒子中溢出，然后overflow：hidden溢出隐藏

四、精灵图技术css sprites
    网页上有很多小的岁图片，不管图片大小，一个图片就会发起一次http请求，很多碎图片就会发起很多http请求，降低速度
    我们将这些碎图片整合在一张图片上，只会发起一次http请求， 提高网页加载速度，这就是精灵图技术。
    1、应用
        1、通过盒子的宽高限制精灵图
        2、通过background-position得到具体的精灵图小图片
    2、精灵图制作
        1、所有的小碎图片必须是png
        2、精灵图不要太大，保证小碎图片可以盛放
        3、小精灵图摆放：从上到下摆放，最好颜色相近的放在一起，这样可以节省空间
    3、精灵图分类
        1、水平精灵图：将所有的图片打包在一行
            1、容器宽度是受约束的，宽度不能超过：后一张图片起始位置-前一张图片的终止位置，比如123，1终止和3起始位置之间是容器2的最大宽度  
            2容器高度是自由的，高度任意，因为后面没有其他图片了，图片可以在垂直方向平铺，实现渐变效果
            3调整精灵图的位置，就是调整背景图片的横坐标位置
        2、垂直精灵图：我们将图片，在垂直方向合并
            1容器的高度受限制：后一张图片的结束位置-前一张图片的起始位置 和上面同理
            2修改图片位置，就是修改垂直方向的位置
            3可以在水平方向平铺 
        3、定点精灵图：是工作中最常用的一种精灵图，特点就是在一个图片中，随意放置图片，使用的时要找准位置
            1宽度和高度都是受限制的，受到周围图片的限制，常将容器的宽高设置成icon图片的宽高
            2不论是水平方向还是垂直方向，通常是不能平铺的，一旦平铺后面图片收到限制
        
        例子：NO3和NO4
        总结：精灵图就是说自己把很多小图片整合到一起，然后所有需要用到这些图片的都用这张图，然后调整位置就行了

五、定位：就是确定一个元素的定位，确定元素是基于什么样的方式进行渲染
    1、脱离文档流的三种方式：
        1、浮动
        2、绝对定位
        3、固定定位
    2、可以通过position属性设置
        1、relative：相对定位
        2、absolute：绝对定位
        3、fixed：固定定位
        4、static：静态定位，渲染在文档流中，默认值

    3、相对定位：相对于元素原有位置的定位
        注意：这种定位的元素没有脱离标准文档流，因此对于他的定位设定不会影响其它兄弟元素
        相当于占了个坑 ，但是人不在这里
        一旦元素设置了position（除了static），会激活4个属性top left right bottom，这四个属性可以定义位置偏移
                                        四个属性优先级：left优先right ，top优先bottom，所以工作中尽量用top和left
            注意：正负
                正：乡中心方向便宜要设置正值
                负：向边缘方向偏移要设置负值
        .box2{
            /* 设置相对定位 */
            position: relative;
            top: 100px;
            left: 100px;
        }
        注意：在css坐标系中
            水平方向右正左负，垂直方向下正上负
        应用：
            元素并未脱离标准文档流，因此这类元素边距的设置，会影响兄弟元素
            但是对这类元素的偏移量的设置，不会影响其它兄弟元素（因为偏移量设置不会改变容器尺寸）
            比如更改文字渲染位置，更改图标位置
            有时候还会用相对定位来辅助绝对定位

        相对定位真是个好东西！！！挪就完事了，优点：
            1、不会脱离标准文档流，
            2、不会影响后面的元素

    4、绝对定位
        position：absolute
        绝对定位因为脱离了标准文档流，会影响后面的兄弟元素
        设置 position属性的时候,如果设置的属性值是 absolute,此时就是绝对定位
        默认相对body定位
            在相对定位中,相对于原有位置进行定位的
            在绝对定位中,相对于body元素定位的
            注意
                设置top的时候,根据body的顶边定位
                设置 bottom的时候,相对于屏幕的底边定位
                left和 right是相对于body左右边定位的。
                    这些优先级和相对定位是相同的
        绝对定位影响宽高:在未设置盒子的宽度和高度的时候,我们可以通过绝对定位的偏移量:top, bottom,
        right,let来设置盒子的宽高,然而相对定位不可以
        
        绝对定位特性
            1、就近原则：嵌套的盒子设置了绝对定位,它会寻找离他最近的设置了定位的祖先元素(绝对定位,相对定位,固定定
            位),以此来确定定位的偏移量。也就是说,此时不再以body定位,而是相对设置了定位的祖先元素定
            定位顶点:绝对定位是相对于父元素的padding定点(包含 padding)进行定位设置的。设置border会影响定位的效果。

            2、display:不论是行内元素,还是块元素,设置了绝对定位, display属性失效,定位的结果
            不论是块元素还是行内元素（因为display失效了）,都可以直接设置宽高

            3、压盖现象:元素设置了绝对定位,此时会有压盖现象,后面的元素会显示在前面的元素上面

            4、绝对定位居中
                我们可以根据绝对定位的特性让元素居中
                绝对定位是相对于元素左上角的一点进行定位的,我们可以将其设置成50%此时该元素的左上角一点
                将在页面中心,我们通过 margin向上和向左平移宽高的一半,既可以实现元素的居中(兼容块元素和行内元
                素,绝对定位不会区分块元素和行内元素)

    5、固定定位：也会脱离文档流
        写法：position:fixed(E6不支持,只能通过 absolute模拟）
        固定定位是相对于浏览器窗口的定位,由于相对于浏览器窗口的定位,因此与父元素的定位无关,其特点
            1、定义相对于浏览器窗口，与父元素的定位无关
                解读：比如浏览器带上下滚动条，不论怎么滚，这个固定定位的元素就在这里，动都不动，很多广告就是这个搞的
                比如淘宝顶部导航栏，不论怎么滑动滚动条，菜单栏都在顶部
            2、脱离文档流,会影响兄弟元素(后面的兄弟元素会顶上来)
            3、不论是块元素,还是行内元素,一旦固定定位,可以直接设置宽高
            4、display属性失效
            5、可以通过偏移量设置盒子的宽高(没有设置 width或者 height)
            6、优先级:left> right,top>botm
            7、如果偏移量一旦设置了负值,那么盒子将移出视口,我们将看不到这部分盒子(所以在工作中,尽量
            不要设置负值)
            8、不受父元素定位影响！！

六、遮盖
    一旦盒子设置了定位（相对，绝对，固定），就会产生遮盖现象，遮盖是指盒子被另一个盒子盖住，默认遮盖顺序有两个特点
    1、设置定位的盒子，会遮盖住没有定位的盒子（包括浮动的盒子）
    2、如果盒子都设置了定位，后面的盒子会遮住前面的盒子（写的前后顺序）

    3、Z-index
    默认情况下,如果盒子都设置了定位,遮盖的顺序是按照盒子创建的顺序遮盖的,后面的会遮盖住前面的
    为了能够让盒子遮盖的顺序自定义,设置了定位的盒子会激活z-index:属性,来设置盒子遮盖的顺序。
    z-index:属性值是一个数字(不要带单位),遮盖的顺序是由该属性值的大小决定的,越大优先级越高,其特点
        1、只有设置了定位的盒子才激活z-index,因此定位的盒子可以设置z-index,没有定位盒子不能设置z-
        index(包括浮动的盒子)。
        2、z-index默认值是auto,可以看成是0,没有定位的盒子不能设置z-index,但是我们可以将其z-index看
        成0,如果 z-index小于0,会渲染盒子(包括未定位的盒子)底部,只有大于等于0的时候,才会渲染在上面。
            解读：如果给一个定位了的元素z-index设置了负数，哪怕有一些元素没定位，如果他们发生遮盖现象
            z-index为负数的也会在未被定位的元素下面
        3、设置的z-index值越大,就会渲染在最前面,谁的大,進在前面,注意:z-index属性值通常是整数。
        4、如果盒子设置了相同的z-index,此时盒子会根据创建的顺序决定谁在前面,不论是正值还是负值,后
        创建的盒子渲染在最前面。
        5、盒子的遮盖顺序不仅仅与自己的z-index相关,还与设置了定位的父盒子相关,父盒子z-index高的,
        不论子盒子z-index设置了多少,都会渲染在父盒子z-index低的子盒子的前面,这一现象我们称之为拼爹。
            解读：拼爹：两个定位的父盒子12， 两个定位子盒子34，其中1比2的z-index大，34都用绝对定位且发生
            遮盖现象，那么3就会压在4前面。

七、html hack
    兼容性：浏览器存在兼容问题，我们在书写网站的时候，必须考虑给不同的浏览器写不同的代码
    多啦a梦测试https://www1.pconline.com.cn/pcedu/specialtopic/css3-doraemon/

    Hack单词从 hacker(黑客)延伸来的。Hack就是我们针对不同的浏览器去写不同好的html和css
    分为:html的Hack,cSs的Hack。

    html的Hack
        针对不同的浏览器在同一个html文件里,去写不同的html结构。
        IE浏览器有很多兼容性问题,给我们提供了一些接口。
        <!--[if lte IE 9]>
            <hl>亲,版本太低了,需要升级高级浏览器~/hl
        <![endif]-->
        表示Hack符里面的内容只在E9及以下的浏览器内显示,IE10及以上或者高级浏览器会认为这是注释。
        if是如果,lte是less than or equal,小于或者等于,IE浏览器,9代表版本。 endif结束这个Hack
        lte: less than or equal小于等于
        lt: less than小于
        gt: greater than大于

八、css hack
    图片
九、IE6兼容
    1、IE6不兼容交集选择器里的类选择器连写,如:div.box.cl不兼容
    解决方法:使用标签和一个类的交集。其他的7种选择器完美的兼容(标签、id、类、交集(div.box)、a
    后代、并集、通配符)
    2、如果不写DTD,IE6里的盒子是内减的,其他浏览器是外扩（ie6什么高度宽度算padding和border？）。
    解决方法定义DTD。dtd<!DOCTYPE html>
    3、不能有小于字号的高的盒子,如果盒子高度小于默认字号,不会正常显示。高度会是最小的字号。
    解決方法:单独给IE6浏览器,强制给个很小的字号。font-size: 0px
    4、不浮动的盒子不会钻到底下,如:有两个盒子,一个浮动一个不浮动,不浮动的盒子不会钻到浮动盒子的
    下面,占有原来标准流的位置。
    解决方法:同级元素之间,要么都浮动,要么都不浮动。不用浮动做压盖效果。用定位做压盖效果。
    5、3px bug：
        举例:有两个盒子,一个浮动一个不浮动,首先像4所说他们不浮动的不会钻上去，会并排显示
        同时他们之间会有一个3 px间距
    解决方案：1、margin-left:-3px用margin移动就好了
            2、同时浮动不就完事了
    6、双倍margin问题，举例：一些浮动元素，有一个与浮动方向相同的方向margin，第一个元素会出现双倍
    边距
    解决方案：
        1、不能用儿子去撑开和父亲的间距，用父亲的padding去挤
        2、设置margin与浮动的方向相反
        3、设置第一个li边距为10px
    7、ie6不支持固定定位
    8、ie678不支持opacity，即透明属性，可以用filter:alpha(opacity=数字)来设置，数字0-100
     
十、css单位
    1、px：像素单位，表示屏幕上的一个点
    2、%：百分比单位，相对于父元素宽高的百分
    3、in：英寸单位，像素与英寸的转化与分辨率有关，分辨率是96，一英寸单位下有96像素点
    4、cm厘米
        1in=2.54cm，1cm包含37.78个像素点
    5、pt：磅
        1pt=1/72英寸，包含1.33个像素点
    6、pc：包含12个点活字
    7、em：相对于字体的大小，要看容器的字体多大
    8、rem：相对于根元素字体的大小
        容器多款，与父元素和自身的字体大小无关，与根元素字体大小有关
        根元素字体：  html{
                        font-szie: 10px;
                    }
    9、ex，表示相当于x-height的高度
        x-height指的是x字母的高度
    10、vw：1vw等于视口宽度的1%
    11、vh：1vw等于视口高度的1%
    12：v'min、vmax：vw和vh最小、最大值 

十、BFC与IFC
    1、FC：Formatting Context（格式化上下文），是W3C CSS2.1规范中的一个概念，它是页面
    中的一块渲染区域，并有一套渲染规则，它决定了其子元素如何定位，以及和其它元素的关系和相互作用
    2、BFC bolck--- 块级格式化上下文
        布局规则：
            1、内部的盒子会在垂直方向，一个个放置，每个盒子独占一行。
            2、盒子垂直方向的距离由margin决定，属于同一个bfc的两个相邻box上下margin会发生重叠
            3、每个元素的左边，与包含的盒子的左边相接触，即使存在浮动也如此
            4、BFC的区域不会与float重叠（例子）
                解读：这就是为什么float的元素都一个接着一个排在一起而不是重叠在一起
            5、bfc就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之也如此
                解读：两个大div，第一个div里面都是元素哈，如果产生了bfc，第二个div如果设置浮动是不会浮动到上面去的
            6、计算bfc高度，浮动元素也参与其中
        产生bfc：
            1、根元素
            2、float属性不为none
            3、position为absolute或者fixed
            4、display 为inline-block， table-cell， table-caption，flex
            5、overflow不为visible
    3、IFC Inline 内敛格式化上下文 主要是行内元素布局
        1、IFC的line box（线框）高度由其包含行内元素中最高的实际高度计算而来（不受垂直方向的padding和margin影响）。
        2、IFC中的line box一般左右都紧贴整个IFC，但是会因为float元素而扰乱。当float元素会位于IFC与line box之间的时候，
        会使line box宽度缩短。
        3、同一个IFC下的多个line box高度会不同。
        4、ifc中是不可能有块级元素的，当插入块级元素（p中插入div）会产生两个匿名块与div分隔开，即产生两个ifc，每个ifc对外表现为块级元素，与div垂直排列 

        作用：
            1、水平居中：当一个块要在环境中水平居中时，设置其为inline-block会在外层产生ifc，通过text-align则可以使其水平居中
            2、垂直居中：创建一个IFC，用其一个元素撑开父元素的高度，然后设置其为vertical-align:middle,其它行内元素
            则可以在此父元素下垂直居中
        行内元素的边缘是content-box
        行内块inlin-box的边缘是margin-box
        行内块元素如果没有内容，则基线以下边界对齐，如果有内容，则以内容的基线对齐。
        行内块有多行内容，则以最后一行元素的基线对齐。
        行内块：整体是行元素，一字排列，不过里面内容是以bfc形式呈现，即外部ifc特征，内部bfc特征
    4、GFC GridLayout 网格布局格式化上下文
    5、FFC Flex 自适应格式化上下文


