## 1、设计模式
设计模式是可以被复用的，编目分明的经验总结，让我们写的代码可复用，提高我们代码的可维护性。
## 2、原型与继承
原型：是每一个函数天生拥有的属性，它的值是一个对象
特点：在原型中所有内容天生可以被每一个实例化对象所访问
继承：类与类之间的继承
继承方式：
    类式继承:继承原型数据
    构造函数式继承:继承实例数据，把父类的构造函数call给子类实例对象
    组合式继承:
    寄生式继承:继承原型数据
```js
function inherit(Child,Parent){
    function F(){
        this.constructor = Child;
    }
    F.prototype = Parent.prototype
    Child.prototype = new F();
    //实现对静态数据的继承
    for(let key in Parent){
        if(Parent.hasOwnProperty(key)){
            Child[key] = Parent[key];
        }
    }
}
```
    寄生组合式继承
类中有三类数据
    实例数据 this.name = name
    原型数据 类名.prototype.name = name
    静态数据 类名.name = name，实例访问不到，只能通过类来访问

## 3、闭包、垃圾回收与闭包类
```js
function outer(){
    var a = 10;//想在外部访问这个a
    return function inner(){
        console.log(a++);
    }
}
//闭包函数一直在引用外部的a变量，所以a不能被销毁
var fn1 = outer();
fn1();//11
fn1();//12
fn1();//13
var fn2 = outer();
fn2();//11
fn2();//12
fn2();//13
//普通函数执行完就销毁了,被垃圾回收机制自动回收，因为这个a没人用了
function demo(){
    var a = 0;
    console.log(a++);
}
demo();//0
demo();//0
demo();//0
```
由于闭包中一直在缓存数据，所以闭包在执行完毕不会被销毁。

**用IIFE函数去优化闭包**
```js
var fn1 = (function(){
    var a = 1;
    return function inner(){
        console.log(a++)
    }
})();
fn1();
fn1();
fn1();
//有什么用？
//定义闭包类
function People(name){
    this.name = name;
}
//实例化
var p1 new People('xiaobai');
console.log(p1);
//若定义同名函数，由于声明提前的关系，后面的会覆盖前面的构造函数，打印p1啥属性也么得，想解决这个问题可以用闭包和iife来保护people类
function People(){
    console.log('这是个函数 ')
}

var People = (function(){
    var id = 0;
    function People(name){
        this.name = name;
        //可以给每个实例对象id+1
        this.id = id++;
    }
    return People;
})();
//实例化
var p2 = new People('小红')
```


## 4、简单工厂模式
解决的问题：在创建对象时候往往会衍生一些副作用（例如创建了全局变量），我们可以将这个创建过程封闭起来，创建完成将结果返回，这样可以屏蔽这些副作用对全局作用域的影响。
实现：通过将创建过程封装在一个函数内，并将创建的结果返回
特点：
    1、避免副作用的产生（污染全局作用域）
    2、我们看不到他的撞见过程，只能看见创建的结果
    3、往往创建的是一个单一的产品
    4、我们可以简简单单对简单工厂模式方法改造实现更多的需求
```js
//简单工厂模式，避免污染全局作用域。
function factory(name,age,sex){
    var obj = {
        name:name,
        age:age,
        sex:sex,
    }
    return obj;
}
```

## 5、增强工厂
作用：对类实例化的时候，对类拓展（实例化对象），而不会影响原类
特征：
    1、在工厂内部创建类的实例化对象（寄生）
    2、对实例化对象进行拓展（增强）
    3、将实例化对象返回（工厂）
```js
function People(name,age,sex){
    this.name = name;
    this.age = age;
    this.sex = sex;
}
//方法
    People.prototype.getName = function(){
        console.log(this.name);
    }
//创建实例
var p1 = new People('张',20,'男');
var p2 = new People('刘',20,'女');
var p3 = new People('王',20,'女');
//需求：给性别为女的加一个方法hello，可借助增强型工厂

function factory(name,age,sex){
    var p = new People(name,age,sex);
    //增强型工厂
    if(p.sex==='女'){
        p.msg = 'hello'
        p.say = function(){
            console.log(p.msg);
        }
    }
    return p;
}
//并没有影响原来类的创建
```

## 6、安全工厂
又称安全类，比如Array类，使用new创建也可以，直接Array(1,2,3)也可以
步骤：
    判断当前对象是否是当前类的实例化对象
        是：执行业务逻辑，比如对当前对象赋值
        不是：执行简单工厂业务逻辑（返回一个实例化对象）
```js
function People(name,age){
    if(this instanceof People){
        //如果不是当构造函数用，就是不加new，this指向window的
        this.name = name;
        this.age = age;
    }else{
        return new People(name,age);
    }
}
```
## 7、工厂方法
用来处理多个类的创建，本质是对多个类的创建的封装，可以使用户不必关心多个类的创建，而将经历放在工厂方法的实现上。
```js
//创建动物
function Dog(type,name){
    this.type = type;
    this.name = name;
}
function Cat(type,name){
    this.type = type;
    this.name = name;
}
function Pig(type,name){
    this.type = type;
    this.name = name;
}
var dog = new Dog('狗','1');
var cat = new Cat('猫','2');
var pig = new Pig('猪','3');
//要关注于类的创建，要记住名字方法等。
function animal(type,name){
    //根据type区分不同的类
    if(type == '猫'){
        return new Cat(type,name);
    }else if(type == '狗'){
        return new Dog(type,name);
    }else if(type == '猪'){
        return new Pig(type,name);
    }
}
```

## 8、原型模式
让类的原型指向父类的实例对象，这样该类创建的实例可以共享父类原型对象上的数据
    其实就是一个类式继承（原型式继承）
是一种创建型的设计模式
基于js的原型链继承的原理。 

就是类式继承

## 9、单例模式
是能被实例化一次的类或者对象（只能存在一个）
特点：
    1、只允许实例化一次的对象类
    2、对于十分复杂的对象类，往往可以节省资源占用
    3、通常也被用来管理命名空间。
作用：管理命名空间，管理数据、方法的存储
应用：
    一些代码库中命名空间就是单例设计模式实现的
    管理数据的存储，例如模拟静态变量
使用闭包来搞,闭包里存一个
```js
 var Single = (function(){
    //定义类
    function Demo(){
        this.msg = 'hello'
        //省略一万行
    }
    //方法
    Demo.prototype.getMsg = function(){
        console.log(this.msg);
    }
    //存储类的实例化对象
    var s = new Demo();
    return function(){
        return s;
    }
 })();

var s1 = Single();
var s2 = Single();
```
也是只有一个实例,s1===s2为true，因为function返回的是一个闭包函数，这个函数return s，
var Single=。。。直接执行function，也就是Single是一个函数，return s，
那么不论下面执行几次Single()，返回的都是闭包函数外面的那个s，就那么一个实例。


## 10、惰性单例
上面的单例模式，必然创建一个实例对象s，需求：想创建实例的时候再创建，不需要创建的时候连一个实例对象都不想创建。
惰性单例：延迟单例类的实例化事件
实现：
    1、通过闭包将惰性类封装起来，避免外界访问
    2、在闭包的返回函数中，我们判断闭包类有没有实现
        没有实现再去实例化
        实现了直接返回
    3、当调用这个闭包的时候才尝试去实例化，这样就拖延了实例化的时间
```js
 var Single = (function(){
    //定义类
    function Demo(){
        this.msg = 'hello'
        //省略一万行
    }
    //方法
    Demo.prototype.getMsg = function(){
        console.log(this.msg);
    }
    //存储类的实例化对象
    var s;
    return function(){
        if(s ){
            return s;
        }else{
            s = new Demo();
            return s;
        }
    }
 })();
var s1 = Single();
var s2 = Single();
```

## 11、静态变量
一旦被定义，只能读取，无法修改
原理
    2、js中任何变量，任何方法，只要能够访问，都可以被修改
    1、如果这些变量不能被访问，那么我们是无法修改的。
    3、定义在一个比暴力的变量我们访问不到，但是比包中返回的方法是可以访问闭包作用域中的数据的。
    4、在这个方法中，我们只提供对数据的取值，不提供赋值，那么就可以实现静态变量了。
局限：只能定义值类型的数据（其实工作中定义的静态变量也仅仅是值类型的。）
```js
var Conf = (function(){
    var _data_ = {
        num:100,
        color:'red'
        //注意这里存个引用数据类型的数据，是能被修改的！比如存个数组，可以直接给赋值个长度！
    }
    return function(key){
        return _data_[key];
    }
})()
var color = Conf('color');//red
var num = Conf('num');//100
var msg = Conf('msg');//undefined

```
## 12、适配器模式
将一个类（对象）的接口、属性、方法等适配到另一个类（对象）的接口、属性、方法来解决类（对象）之间不兼容的问题，实现类（对象）之间的解耦
比如mac上的雷电3和usb的转接器就是适配器。
特点：
    结构型的设计模式
是用来解决接口之间不兼容问题的，是对数据进行的一个拆分再封装的一个过程，需要一定的开销，但是这些开销远比修改原有业务逻辑的成本低。
```js

```