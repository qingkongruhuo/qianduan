ES5新增了严格模式
js诞生之初只是为了实现一些简单的交互，随着技术的发展，js需要做的事情越来越多。
比如定义变量省略var污染全局
执行eval方法污染全局环境。。。。
```js
var color = green;
function demo(){
    color='red';
}
console.log(color);//red 这是能访问到的！如果不写var相当于定义了一个全局变量挂到window上了
```
**1、进入严格模式** 
直接添加一行use strict
如果在js第一行use strict，代码处于严格模式下
如果在某个函数内部use strict，局部严格模式，函数内部严格模式，比如写错了，啥时候调用这个函数啥时候就能检测到错误。
```js
'use strict'//全局严格模式
function demo(){
    color='red';
}
console.log(color);//color：报错undefined
```
1、全局严格模式定义变量不能省略var，省略就报错
2、局部严格模式，只有当函数执行的时候才能进入严格模式，函数外面仍然是正常模式，知道函数执行完毕严格模式解除
3、全局函数作用域
    正常模式下，全局函数的作用域是window，进入严格模式，全局函数作用域是undefined，以前在正常模式下，在函数内部通过this修改数据会污染全局作用域，严格模式下会抛出错误，不会污染全局作用域。
    严格模式不能跨标签，也就是连写几个script标签，只针对当前标签
```js
function demo(){
    this.color = 'red';
}
demo();
console.log(color);//此时可以打印！因为demo的作用域是全局的，this指向window，如果一旦执行了函数，就会把color通过this挂载到window上，污染全局作用域。
//但是如果把demo当构造函数，new一个对象出来，那没事，因为this指向实例化对象。
```
```js
'use strict'
function demo(){
    this.color = 'red';
    console.log(this);
}
demo();//打印this是undefined
console.log(color);//这就找不到color了
```
4、函数参数
    正常模式下，函数可以定义同名形参，但是会产生覆盖问题，前面的参数被覆盖，严格模式不允许定义同名参数
```js
function demo(color,color){
    严格模式不能这么干会报错。
}
```
5、对象属性，和上面一样
    严格模式下，在通过对象字面量形式定义对象时，不允许定义同名的属性，定义同名的属性，前面的会被覆盖，目前还没有浏览器提示错误（默认允许），
 ```js
var obj = {
    color:'red',
    color:'green'
}
```   
6、delete
    正常模式下可以删除变量，函数等，但是没有删除成功。
    严格模式下只能用来删除对象的属性，删除变量会报错
```js
'use strict'
var obj={
    key1:'value1';
}
delete obj.key1;
```
7、关键字、保留字、特殊变量
    严格模式下不允许使用关键字保留字特殊性变量来定义变量
        关键字：for var 
        保留字：当前版本没用，将来会用：class public
        特殊变量：arguments
    严格模式用这些来定义变量会抛出错误。
8、8进制
    js以0开头出现的数字：如果0后面的数字有大于8的，就当它是十进制，如果全小于8，当它是8进制
    严格模式下不允许用8进制，就防止出现这样的错，即数字不能用0开头
9、特殊字符：
    \012表示换行，
    严格模式可以使用转义字符（比如\'表示字符'），但是不允许使用特殊字符
10、eval
    eval可以将字符串作为语句去执行，但是会污染全局作用域，严格模式下可以避免对全局作用域的污染，
    ES5严格模式对eval的处理是识别该特殊变量，并没有改变其功能，因此仍然想使用原有的功能，我们可以将eval赋值给一个变量，然后通过该变量去执行
   
```js
eval('var a = 10 ; console.log(a)');
console.log(a);
//本来想让a只在eval里面执行,结果外面也能访问到了
```
```js
'use strict'
var newEval = eval;
newEval('var a = 10;');
console.log(a);//还是可以，es5只是识别eval这个关键字
```
11、arguments.callee不能用
    在函数内部访问该函数：解决函数的执行时与函数名称耦合的问题（常用语递归）
    在浏览器渲染js的时候，并不是直接执行js语句，而是将js编译执行编译的代码。但是由于arguments.callee无法被编译引擎优化，所以严格模式不允许使用。js是动态语言，执行时候的作用域，因此在编译的时候js没有执行，因此arguments.callee到底哪个函数名称，编译引擎不知道，所以无法优化。
```js
function add(num){
    if(num<=1){
        return num;
    }
    //return num+add(num-1);递归
    return num+arguments.callee(num-1);//一样的意思
}
```
12、with
    可以在代码执行的时候改变代码执行的作用域，严格模式下不能使用with，因为with不能让编译引擎优化。（函数是运行时才开始执行的，用with后编译时可能会出现紊乱，编译引擎无法优化，其实上面的arguments.callee也是这个问题，只有真正运行函数了材质到arguments.callee指向谁。）
```js
with(Math){
    console.log(PI);
    console.log(max(1,2));
}
```
