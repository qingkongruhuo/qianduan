**BOM**
    BOM（Browser Object Model）浏览器对象模型，是js的重要组成
部分。它提供了一系列对象用于与浏览器进行交互，这些对象通常称为BOM
    ##window窗口对象，它显示整个浏览器窗口，主要用来操作浏览器窗
口。同时window对象还是ECMAscript中的global(全局对象，可以在任意地方访问)对象，因而所有的全局变量和函数都是它的属性。
    widow:docunment（BOM包含DOM）,location navigation screen history

**Document**
    处理页面文档，是dom的顶层元素。

**location**
    用于获取当前页面的地址，并把浏览器重定向到新的页面，打印
location可以看到很多和页面与地址有关的信息。

    location.href='url地址'
    location.hostname 返回web主机的域名
    location.pathname 返回当前页面的路径和文件名
    location.port 返回web主机的端口（80或443：http和https的端口号）
    location.portocol 返回页面使用的web协议，http:或https:
    reload事件:刷新页面
```js
//可以用location获取数据
console.log(location.href);
//修改数据
location.href = 'http://www.baidu.com'//直接跳到百度了
//reload事件:刷新页面
document.getElementByTagName('button')[0].onclick=function(){
    location.reload();
}
```

**navigator**
    提供了与浏览器有关的信息。
    userAgent是最常用的属性，用来完成对浏览器的判断。可以判断是不
是火狐chrome浏览器等，还有一些渲染引擎的信息。
    国内的浏览器就是chrome内核的浏览器，都是换了个皮肤
    window.navigator对象在编写时可以不用window前缀

**screen**
    screen用来获取屏幕的信息
    screen.height:整个屏幕的高
          .width:整个屏幕的宽
          .avaiHeight:整个屏幕的高减去系统部件的高（可用的屏幕高度）
          .avaiWidth:整个屏幕的宽减去系统部件的宽(可用的屏幕宽
          度)

**history**
    包含浏览器的历史
        比如新打开一个页面，history.length为1，再打开百度，为2，再打开京东，为3，可以帮我们切换页面。
    back()返回上一页
    forward()返回下一页
    go('参数') -1表示上一页，1表示下一页
    document.referrer:网页来源，单词写错了一直没人改

## ES5
**1、JSON.parse(str,fn)**
    JSON对象属性必须加双引号
    将json字符串解析成js对象
        JSON.parse(str,fn)
            str:处理的字符串
            fn:回调函数
                返回值表示这次处理的结果
                第一个参数表示属性名称
                第二个参数表示属性值
                this指向当前遍历的对象
            是从叶子节点到根节点的方向遍历的，外部向内部遍历,如下例子
```js
//定义json字符串
var str = '{"a" : 1, "b" : "2", "c" : { "d" : 4 }}';
//解析成对象,老方法
var obj = JSON.parse(str);
//结果：{a:1,b:"2"...},会发现b属性的值是字符串，与预期不相符，这时想处理这个b属性就可以用回调函数
var obj1 = JSON.parse(str,function(){
    console.log(arguments,this)
})
// Arguments(2) ['a', 1, callee: ƒ, Symbol(Symbol.iterator): ƒ] {a: 1, b: '2', c: {…}}
// Arguments(2) ['b', '2', callee: ƒ, Symbol(Symbol.iterator): ƒ] {b: '2', c: {…}}
// Arguments(2) ['d', 4, callee: ƒ, Symbol(Symbol.iterator): ƒ] {d: 4}
// Arguments(2) ['c', {…}, callee: ƒ, Symbol(Symbol.iterator): ƒ] {c: {…}}
// Arguments(2) ['', {…}, callee: ƒ, Symbol(Symbol.iterator): ƒ]0: ""1: {}callee: ƒ ()length: 2Symbol(Symbol.iterator): ƒ values()[[Prototype]]: Object {"": {…}}
//可以看到回调函数是遍历JSON对象的，且第一个参数是key，第二个参数是value，遍历的是每个属性和属性值组成的对象。
//遍历顺序：从叶子节点向根节点遍历。a,b,d,c,最后大的括号也看成的对象，但是没key看做''

//如果属性值是数字，可以转成数字
var obj2 = JSON.parse(str,function(key,value){
    if(typeof value==='string'){
        return +value;
    }
    return value;
})
```             
**2、JSON.stringify**
    将js对象转化成json字符串
        JSON.stringify(obj,fn)
            obj:处理的js对象
            fn:回调函数
                返回值表示这次处理的结果
                第一个参数表示属性名称
                第二个参数表示属性值
                this指向当前遍历的对象
            是从根节点到叶子节点的方向遍历的，内部向外部遍历,
```js
var obj = {
    a: 1,
    b: '2',
    c: {
        d: 4
    }
}
var str = JSON.stringify(obj);//'{"a" : 1, "b" : "2", "c" : { "d" : 4 }}'
//将字符串能转数字的转数字
var str1 = JSON.stringify(obj,function(key,value){
    if(typeof value ==='string'){
        return +value;
    }
    return value;
});

```

**3、判断数组**
    之前判断数组的方法：
        1、Object.propotype.toString.call(obj);//看看类型字符串中有没有Array？
        2、通过构造函数
        obj.constructor ===Array
        3、判断是否是实例化对象
        obj instanceof Array
    ES5:Array.isArray(obj);，返回boolean值。

**4、查找数组成员**
    ES5为数组拓展了两个方法：indexOf(),lastIndexOf()来获取数组成员的索引
        参数就是这个成员，
        返回值是索引值
            如果成员存在返回索引值
            不存在返回-1
        查找成员是不会做数据类型的转换，是真正的全等查找
        indexOf从前往后，last是从后往前
```js
var arr = [1,'2',2]
var result = arr.indexOf('2');
var result2 = arr.indexOf(2);
console.log(result,result1);//1，2，不会转换数据类型去检索
```

**5、forEach和Map**    
    forEach用来代替for，是数组遍历器方法，并没有溢出循环，而是将循环封装在遍历器方法forEach内部
        参数是回调函数
            三个参数：成员值、索引值、原数组
            this指向window
            返回值对foreach方法执行结果无影响
        forEach返回值始终是undefined
```js
//定义数组
var arr = ['1','2','3','4']
//去遍历：
arr.forEach(function(item,index,arrOrgin){
    console.log(item,index,arrOrgin);
});
//'1',0,Array[4]\'2',1,Array[4]...
```
    就是用来代替for循环的，想用for循环操作什么东西，直接把内容写在forEach回调函数中就行了。

    Map：和forEach很像，但是它的返回值有意义，映射新数组
        参数是回调函数
            三个参数：成员值、索引值、原数组
            this指向window
            返回值是map方法执行的结果数组的成员
        map方法返回值是一个新数组，每一个成员就是每一次遍历成员时，回到函数的返回值（返回的结果）。
 ```js
//定义数组,需求：返回每一个成员的第一个字符
var arr = ['a1','b2','c3','d4']   
var result = arr.map(function(item,index,arrOrgin){
    return item[0];
});
//手动实现
Array.prototype.map = function(callback){
    var result = [];
    for(var i = 0;i<this.length;i++){
        result.push(callback(this[i],i,this));
    }
    return result;
}
```

**6、fill与filter**    
    arr.fill(成员)：填充数组方法
    作用：我们通过new Array(len)创建只有长度，没有成员，因为没有成员，所以不能用forEach和map，为了遍历数组可以想数组中填充成员。
    arr.fill(1);数组里面填满了1

    filter：过滤器实现对数组的过滤
        使用方法和forEach相同
            参数是回调函数，回调函数三个参数：成员值、索引值、原数组
                返回值就是过滤条件
        filter方法返回值是由符合条件的成员组成的新数组。
```js
//定义数组,需求：返回第一个字符是a的
var arr = ['a1','b2','a3','d4']  
var result = arr.filter(function(item,index,arrOrgin){
    //回调函数返回值是过滤条件
    return item[0]=='a';
})
```        

**7、some和every** 
some：断言判断数组中是否有些成员满足条件
    使用和filter一样，范数回调函数
        三个参数：成员值、索引值、原数组
            返回值是判断的条件
    some方法返回值
        true：至少有一个成员满足条件
        false：一个成员都不满足条件
注意：some遇到一个满足条件的成员就停止执行。
```js
//定义数组,需求：判断arr数组中是否有成员带a
var arr = ['a1','b2','a3','d4']  
var result = arr.some(function(item,index,arrOrgin){
    //回调函数返回值是过滤条件
    return item[0]=='a';
})
//result:true
```  
every：断言判断数组中是否全员成员满足条件
    使用和filter一样，范数回调函数
        三个参数：成员值、索引值、原数组
            返回值是判断的条件
    every方法返回值
        true：全体成员满足条件
        false：有一个成员不满足条件
注意：every遇到不一个满足条件的成员就停止执行。

**8、reduce与reduceRight**  
这两个方法是累加，reduce是从前向后累加，reduceRight是从后向前累加。
    对所有成员逐一处理，并将结果返回。
    参数
        回调函数
            四个参数：
                上一次累加的结果
                当前成员值
                当前索引值
                原数组
            返回值就是单次累计的结果，会在下一次执行的时候作为第一个参数传递。
        初始化的值：可以指定数组从你想的值开始累加
            可有可没有：
                比如[1,2,3,4]，arr.reduce(function(res,item,index,orgin){
                    return res+=item;
                });从0累加
                arr.reduce(function(res,item,index,orgin){
                    return res+=item;
                },11);从11累加
    
注意：reduce是从第二个成员开始遍历，第一个成员在第一次遍历的时候作为第一个参数
        如果reduce方法传递了第二个参数，将从第一个成员遍历，第二个参数就是初
    始化的值
     reduceRight是从导数第二个成员开始遍历


**9、函数绑定与函数的柯理化**   `重点，尤其是柯理化`
ES5对函数拓展了bind方法:`重点！bind很好用`
    作用：为函数板顶作用域（当函数执行的时候，改变函数的作用域，并传递参数）
    目前为止改变作用于的方法|关键字：bind,call,apply,with,eval

call与apply的区别:
    1、他们都是改变函数作用域的方法，`都是在调用该方法的时候执行并改变作用域`,第一个参数都是改变的作用域，比如改this指向，就可以把this写在这里
    2、区别：
        call从第二个参数开始就是表示传递给函数的参数
        apply第二个参数是数组，每一个成员表示传递给函数的参数

bind与call类似
    1、参数
        第一个参数表示改变的作用域对象
        从第二个参数开始表示传递的参数
    2、区别
        bind调用不执行，会返回一个新的方法，是可以执行的方法
        var fun = function.bind(this,1,2,3);
        fun();
        bind方法实现也是通过apply实现的
bind是通过两项技术实现的
    1、函数绑定：函数作为参数传递的同时，可以改变函数的this指向
        作用：改变this指向
    2、函数科柯里化：一个接收了多个参数的函数，我们一个一个的传递参数，在函数执行的时候，传递剩余的参数并得到结果。
    比如fn(1)(2,3)(4),打印1+2+3+4
        作用：增强了函数的实用性，和函数的重载很像
            函数的重载是在函数内部执行的
            函数柯里化是在函数外部执行的（没有修改函数的内部结构。类似装饰者模式）
```js
function demo(){
    console.log(this,arguments);
}
var obj = {};
//之前实现bind的效果，因为一用call就执行了
var fun1 = function(){
    demo.call(obj);
}
fun1();
//现在
var fun2 = demo.bind(obj);
fun2();
```
`bind实现`
```js
/*
*@fn 执行的函数
*@context 上下文对象
*****/
function bind(fn,context){
    //返回函数并且要执行
    return function(){
        //更改指向并传递参数
        fn.apply(context,arguments);
    }
}
// 柯里化是指这样一个函数(假设叫做createCurry)，他接收函数A作为参数，运行后能够返回一个新的函数。并且这个新的函数能够处理函数A的剩余参数。

function curry(fn){
    //Array.prototype.slice.call(arguments)：arguments对象调用了slice方法而已。（arguments不是数组，所以要这么调用）
    //获得参数：
    var args = Array.prototype.slice.call(arguments,1)//从第一个参数开始截取，不把fn截取上
    //返回一个新的函数
    return function(){
        //将参数arguments转成数组
        var arr = Array.prototype.slice.call(arguments)
        //合并参数
        var all = [].concat(arr,args)
        //执行原来的函数，接收剩余的参数（新函数中的参数）
        return fn.apply(null,all);
    }
}
function add(num1,num2){
    return num1,num2
}
var add20 = curry(add,20);//求一个数和20相加
var add200 = curry(add,200);//求一个数和200相加

// bind实现中和函数绑定this和函数柯理化

Function.prototype.icktBind = function(context){
    //获取剩余参数
    var args = Array.prototype.slice.call(arguments,1)
    //this实例存一下
    var fn = this;
    //返回一个函数
    return function(){
        //获取参数
        var arr = Array.prototype.slice.call(arguments);
        //合并到一个新数组中
        var all = args.concat(arr);
        //执行函数
        return fn.apply(context,all);
    }
}
var fn = demo.icktBind(obj,1,2,3);
fn(4,5,6)//可以看到fn的arguments里面有123456
```

**10、对象拓展：原子继承**
继承的是对象！之前学的是继承类.
Object.create()方法是ECMAScript 5中新增的方法，这个方法用于创建一个新对象。被创建的对象继承另一个对象的原型，在创建新对象时可以指定一些属性。
使用Object.create()方法创建对象时，如果不是继承一个原有的对象，而是创建一个全新的对象，就要把proto设置为null。

ES5对对象拓展了一个静态方法，叫create，实现对对象的继承。是对寄生式继承的一个拓展，可以看做是寄生工厂模式。
返回值是一个对象，就是继承了参数对象的新对象。
继承下来的属性和方法是可以修改的。
使用：
    Object.create(对象名,[ propertiesObject ]);返回一个新的对象继承了对象名的对象没属性值
    [ propertiesObject ]可选。该参数对象是一组属性与值，该对象的属性名称将是新创建的对象的属性名称，值是属性描述符（这些属性描述符的结构与Object.defineProperties()的第二个参数一样）。注意：该参数对象不能是 undefined，另外只有该对象中自身拥有的可枚举的属性才有效，也就是说该对象的原型链上属性是无效的。

ES5中的Object.create方法本质上是通过特性实现继承的。

```js
var book = {
    title: 'aaa',
    price: 50,
    getTitle: function(){
        return this.title;
    }
}
//继承对象
var book2 = Object.create(book);
//book2就有相同的属性和方法了（可修改）但是没有属性值哦
//看看就好
function create(obj,props){
    function F(){
        F.prototype = obj;
    }
    var instance = new F()
    //重写
    if(props){
        for(let key in props){
            instance[key]=props[key];
        }
    }
    return instance;
}
```
**11、日期拓展**
toJSON将日期转化为json格式（标准化格式）
日期对象.toJSON();可读性很强、
```js
var date = new Date();
console.log(date.toJSON());
```

**12、严格模式**
**13、特性**
对象是什么我们用属性来说明，属性是什么我用特性来说明。
    特性就是来说明属性的
定义特性：
    Object.defineProperty(obj,prop,property)
    obj表示对象
    prop表示对象的属性
    property表示属性的特性，是个对象。
特性对象有四个属性
    value：表示属性值
    writable：表示属性是否可以修改
        true，false
    enumerable：表示属性是否可以被枚举，比如能否被for in循环
        true，false
    configurable：表示属性是否可以被再次配置（是否可以再次更改这些特性）
        true， fasle    
    除了value，全是布尔值
用特性来添加属性或者修改属性，不是改在原型上的，是直接改在对象里面的
```js
var obj = {
    num: 100   
}
//添加属性
Object.defineProperty(obj,'color',{
    value: 'red'
    //是否可以被修改,
    writable: true;
    //可否遍历
    enumerable: true;
    //再次配置,即可再次 Object.defineProperty(obj,'color',{}),后面会覆盖前面的。
    configurable: true;
})
//此时obj就能访问到color属性了
console.log(obj.color);
//可以被修改
obj.color = 'green';
//设置可以枚举,就能 拿到遍历的属性了
for(var key in obj){
    console.log(key,obj[key]);
}
```
特性方法：不能与value和writable同时出现
    get获取属性值
        没有参数，this指向这个对象，返回值就是这个属性的值
        注意：决不能在该方法内部获取该属性，否则出现递归死循环
        工作中通常获取的是这个值的备用值
    set修改属性值
        参数就是新修改的属性值，this指向这个对象，返回值无意义
        注意：决不能在该方法内部修改该属性，否则递归死循环
        工作中通常修改的是这个值的备用值
```js
var obj = {
    num: 100   
}
//特性方法
Object.defineProperty(obj,'msg',{
    //特性方法
    //获取 方法
    get: function(){
        //禁止在方法内部获取该属性，会出现死循环，触发获取动作又会执行get，无线套娃
        console.log(this,arguments);
        //想获取该属性一般获取备用属性
        return this._msg;
    }
    set: function(value){
        //禁止在方法内部修改该属性，会出现死循环，触发修改动作又会执行set，无线套娃
        // this.msg = 'a';
        console.log(this,arguments);
        //想修改属性一般修改备用属性
        this._msg = 'a';
    }
})
//调用msg的特性方法set
obj.msg = 'idck'
//修改msg的属性值，触发set方法，打印this和arguments，可以看到this是obj，arguments中有idck，说明set能拿到修改的属性值

//调用msg的特性方法get
console.log(obj.msg);
//查看msg属性值，触发get方法，打印this和arguments，可以看到this是obj，arguments啥也没有

console.log(boj);
//会发现obj有个咱们定义的属性，msg，属性值是三个点，这就说明这个属性被设置了特性方法
```

用特性设置多个
Object.defineProperties(obj,propsProperty)
    obj:原对象
    propsProperty：表示属性特性对象
        key：
        value
```js
var obj = {};
Object.defineProperties(obj,{
    num:{
        writable: fasle,
    },
    color:{
        'red',
    },
    msg:{
        set: function(value){
            this._msg = value;
        }
    }
})
```
**14、判断自身属性**
for in循环可以遍历对象的自身属性及原型属性，有时候需要遍历自身属性，不希望遍历原型方法，我们可以用hasOwnProperty方法
    obj.hasOwnProperty(prop)
    对象调用：参数就是这属性
        返回值：true表示自身属性，false表示原型属性
```js
var obj = {}
for(var key in obj){
    if(obj.hasOwnProperty(key)){
         console.log(key,obj[key]);
    }
}
```
**15、获取属性名称**
有时候我们只想获取所有自身属性名称可以使用Object.getOwnPropertyNames
    Object.getOwnPropertyNames
        参数就是这个对象
        返回值就是获取的所有属性，是一个数组
    即使属性设置了特性，也可以获取。
    不能获取原型上的属性。
```js
var book = new Book('Java',59);
//获取自身属性
var arr = Object.getOwnPropertyNames(book)
//得到arr数组，里面存的都是属性名
console.log(arr);
```
**16、查看属性特性**
Object.getOwnPropertyDescriptor(obj,prop):可以查看属性的特性
obj表示这个对象，prop表示这个属性
返回值是一个特性对象
如果属性没设置特性，特性那几个属性都是true，设置了特性的属性，默认值false
**17、特性总结**
1、特性的原有属性，特性默认值都是true
2、特性方法为对象新增的属性，特性默认值都是false
3、特性中的set，get和value，writable不兼容
4、属性的特性默认优先设置value和writable而不是get set
**18、原型新增**
isPrototypeOf方法可以判断对象的原型对象
    注意这个方法查找整个原型链
用法：类的原型.isPrototypeOf(对象)，是原型对象有的方法。
```js
//定义对象
var arr = [1,2,3]
var obj = {}
//判断原型对象
console.log(Array.prototype.isPrototypeOf(arr));//true
console.log(Array.prototype.isPrototypeOf(obj));//false
console.log(Object.prototype.isPrototypeOf(arr));//true
console.log(Object.prototype.isPrototypeOf(obj));//true
```

**19、操作原型**
1、获取原型Object.getPrototypeOf()
    以前获取对象的原型用__proto__，不方便
    与上面辣个等价的。
2、修改原型Object.setPrototypeOf()
    该方法用于设置某个对象的原型
    Object.setPrototypeOf(obj,prototype)
        obj：要设置新原型的对象
        prototype：新原型，可以是null
    `可以手动去实现一些简单继承`
```js
var arr = [1,2]
var obj = {};
arr.push(1)
//可以push进去
Object.setPrototypeOf(arr,null)
arr.push(1);
//报错！因为push方法是原型上的，你把原型对象弄没了就push不上去了
//给obj一个Array的原型
Object.setPrototypeOf(obj,Array.prototype)
obj.push(1);//obj变成了array
//======================
function Book(){

}
Book.prototype.getTitle = function(){
    return this.title;
}
Book.prototype.getTPrice = function(){
    return this.price;
}
var book = {
    title: 'java',
    price: 50;
}
//实现类式继承
Object.setPrototypeOf(book,Book);
console.log(book.getTitle);
```

**20、操作对象**
对象有四个操作：增（拓展）删(delete obj.属性名)改查
对象禁拓就是说
    该对象不能拓展新属性
    但是可以删改查
Object.preventExtensions方法，用于取消对象的可拓展性
    参数就是这个对象
    不可逆，一旦禁拓就无法接触
Object.isExtensible判断禁拓
    false表示被禁拓
```js
var obj = {};
Object.preventExtensions(obj);
obj.msg = '1';//不报错，但是加不进去了
```
对象封闭：不能增删，只能改查
    Object.seal(对象)：封闭对象
    Object.isSealed(对象)：查看对象是否被封闭，true表示封闭
对象冻结：只能查看，增删改都不行
    Object.freeze(对象)
    Object.isFrozen(对象)

    