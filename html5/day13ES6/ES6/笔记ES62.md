## 1、编译ES6
随着ES6,ES6+等新标准的出现，为了有更好的开发体验而要使用这些新特性，但是在浏览器中又不能直接运行，需要一个编译工具来将代码编译成浏览器支持的版本，这就需要babel编译器。**很他妈好用**
说白了，babel可以把es6的代码转成es5的，es5的转成es6的，其他版本同理
安装node之后，可以全局安装babel指令 npm install -g babel-cli
配置.babelrc文件
    通过presets配置项定义编译器
    安装es6babel插件： npm install babel-preset-es2015 **注意在项目目录中运行**
编译文件
    输出到控制台 babel文件
    输出到文件中abbel文件--out-file 文件名
## 2、编译TS
TypeScript是js语法的超集，很多js新的语法就借鉴了ts语法。由微软维护
js：
    弱类型：定义变量没有具体的类型，可以存储任何类型的数据
    动态的：变量存储的数据需要开辟多少内存空间，**不是在定义时说了算，而是运行时动态开辟的**
由于js弱类型，因此变量存储的时什么样的数据，需要多少内存空间，我们在定义的时候无法获知，只能在js运行的时候动态的分配，所以js运行的时候一边处理业务逻辑，一边分配内存空间，对于小型项木来说可以接受，大型项目这种临时分配空间的性能消耗是无法接受的。

    所以在一些强类型的语言中，为变量在定义的时候指明类型，这样运行前就可以针对变量的类型分配内存空间，这
样程序运行的时候就不需要分配空间了，可以减少不必要的资源消耗，所以ts时一个强类型的语言。
    在大型项目中，为了提高代码可维护性，我们通常采用面向对象的编程方式，但是在面向对象的过程中，我们肯定
要使用类，接口，私有属性等，但是这些关键字如extends，implement等js都不支持，但是js为了实现这些功能自身模拟了，为了模拟这些功能势必要产生一些不必要的开销。在大型项目中，这些开销也是无法接受的，所以TS基于面向对象的变成方式，实现了这些关键字。
    TS语法着眼于未来大型项目，但是遗憾的是这些功能并没有一个浏览器实现，也没有一个浏览器要宣称实现，所
以我们就要将其编译成js语言 

安装TSC指令：npm install typescript =g
            查看版本号 tsc -V
        在开发目录中，执行 tsc '文件名' 指令，**即可编译ts文件成js文件**
监听并发布
    1、通过tsc -init创建tsconfig.json配置文件
        在配置文件中可以让它写成ES5语法或者ES6语法等
        其中outDir定义js文件发布的位置，默认往当前目录下，就是编译的TS文件转成js文件的去向。
    2、执行tsc -w监听并发布文件
在后面的课程中，会使用工程化工具来自动化编译ES6和TS(webpack)

## 3、TS数据类 型
在TS中，所有数据类型都要指明，js的类型ts都支持，并且还拓展了any（任何类型），void、never等
类型猜测：
    如果定义的数据没有指定类型，此时程序运行的时候会根据赋值的数据进行类型猜测
    但是不要让ts去猜，消耗内存不说而且很容易猜错
类型推断：
    当我们比程序更了解数据类型的时候，此时可以使用类型推断技术，让计算机按照某种类型去运行。
        语法：
            第一种：<type>数据
            第二种：数据as类型
        并不是类型转换,写的时候只是让数据按照你写的类型去处理，并不是把数据转化过来
```ts
let str:string = '123abc';

let ickt:any = 'hello';
 //类型推断,认为让数据作为字符串去处理
console.log(<string>ickt.toUpperCase())
console.log((ickt as string).toUpperCase())
```


## 4、数组和元组
在TS中定义数组也要指定类型
语法：let arr:type[] = []
此时：
    我们向数组中传递数据，必须和初始化定义的数据类型是一致的
    如果类型不确定，可以把type改成any,尽量别写any，不然要ts有啥用。
```js
let arr:number[] = [1,2,3];
//此时若是添加字符串会报错
//arr.push('aaa');//报错
```

元组：定义类型也要指定规个数，而且要传递数据，数据的个数也要与定义的个数一致
    之后向元组中添加新成员时，必须在指定的类型里
let arr:[type1,type2,...,typen] = [1,2,...,n]
```js
let arr:[number,number,number,number,string] = [1,2,3,4,'a']
//元组添加成员
arr.push('1');//可以，字符串
arr.push(1);//可以，上面的类型中由number
arr.push(true)//不可以报错，上面定义类型时没布尔
```
类型级联：
    如果定义的数据真的没有确定的类型，但是any又太大了，为了缩小类型数据的范围，可以用类型级联技术。
语法：type1|type2|type3
此时定义的数据类型只能在该范围内
```js
let ickt:number|string|boolean = 1;
```

## 5、枚举类型
枚举类型是介于对象和数组之间的数据类型
语法：enum 枚举类型{}
特点：
    既可以像数组那样，通过索引值获取属性名又可以像对象那样，通过点语法获取索引值
注意：
    1、枚举类型的首字母要大写
    2、每一个成员之间用逗号分隔
    3、我们可以为某个成员改变索引值，此时后面成员索引值要递增，前面不变
```js
enum Color{    
    red,green,blue
}
//通过索引值访问
console.log(Color[0]);//red
//通过.语法访问
console.log(Color.red);//red
//改变索引值
enum Color1{    
    red,
    blue=5,
    green
}
console.log(Color1[0]);//red
console.log(Color1[5]);//blue 
```
编译后的代码
```js
var num = 10;
var Color;
(function (Color) {
    Color[Color["red"] = 0] = "red";
    Color[Color["green"] = 1] = "green";
    Color[Color["blue"] = 2] = "blue";
})(Color || (Color = {}));
//通过索引值访问
console.log(Color[0]); //red
//通过.语法访问
console.log(Color.red); //red
//改变索引值
var Color1;
(function (Color1) {
    Color1[Color1["red"] = 0] = "red";
    Color1[Color1["blue"] = 5] = "blue";
    Color1[Color1["green"] = 6] = "green";
})(Color1 || (Color1 = {}));
console.log(Color1[0]); //red
console.log(Color1[5]); //blue 

```

## 6、函数
在js中有
    1、构造函数式
    2、函数定义式
    3、函数表达式
    4、箭头函数
只有函数定义式不需要var或者变量来接受
在ts中要为每一个形参指明类型
语法
    function demo(arg1:type,arg2?:type):type{}
    传递参数
        1、传递的数据类型要一致
        2、**传递的个数要一致**
注意：
    1、函数中的参数以及返回值要定义类型
    2、如果参数可有可无，后面加上问号即可。
函数的返回值通常有三种类型（类似java函数要标注返回值类型）
    1、返回数据，此时函数的返回值类型就是数据类型
    2、没有返回数据，函数的类型为void
    3、如果函数中出现了错误，此时函数的类型是never
```js
function add(num1:number,num2:number,num3?number):number{
    return num1+num2+num3;
}
//使用的时候传递的参数类型与个数必须一致(带问号的可有可无)。
console.log(add(1,2))
```

## 7、泛型
如果参数的类型是任意的，返回的结果也可以是任意的。此时我们可以将类型定义成any
如果希望参数与返回值类型是一致的，那么any不适用，因此可以使用泛型。
function demo<T>(arg:T):T{

}
这样的话，参数与返回值类型就一致了，都是T变量表示的类型。
使用函数有两种方式
    1、demo<type>(数据)
    2、demo(数据)
        此时将猜测类型，常用。
```js
function demo<T>(msg:T):T{
    return msg;
}
//使用函数
console.log(demo<string>('hello'));
```

## 8、类
class 类名{}
类名首字母大写
也是通过constructor定义构造函数
    只能定义参数类型，不能定义返回值类型，后面参数可有可无后面可以添加？
属性:在ts中，我们要将属性在类提中声明类型
    声明的时候可以复制，但必须设置类型
    在构造函数中，也可以为声明的属性赋值，没有生命属性，在构造函数中是不能使用的，
    我们用构造函数的参数为复兴赋值，实现数据由外部流入内部
    属性必须在声明的时候赋值或者构造函数内部赋值。
方法：定义方法的语法与es6相同，但是还是要声明参数和返回值类型。
关键字：ts支持private，protected，public static等
    private，protected，public成本很高，没实现
    static静态属性方法
    ES6中可以在外部添加静态属性，在ts中外部只能修改不能添加
实例化：我们在实例化的时候出现了变量，因此要定义变量的类型。
    变量的类型就是类，传递参数要与构造函数一致。
```js
class Book{
    //声明属性类型
    title:string; 
    price:number;
    page:number|undefined;
    writer:string = 'zhang'//如果构造函数里没写这里必须要赋值
    constructor(title:string,price:number,page?:number){//如果在构造函数后面填一个返回值比如string直接报错
        this.title = title;
        this.price = price;
        this.page = page;
    } 
    //方法
    getTitle:string(){
        return this.title;
    }
    getPrice:number(){
        return this.price;
    }
    //静态
    static num = 20;
}
var book = new Book('zhang',10,10);
//外部添加静态属性方法会报错的
//Book.kkkkk = 100;
```

## 9、继承
TS语法：
    class 子类 extends 弗雷{

    }
继承后，我们可以重写方法，此时优先使用我们重写的方法
如果重写构造函数
    我们要用super实现构造函数的继承
    如果传递了参数，要与父类的参数一致（类型一致，个数一致）
    属性要在super后面赋值
ts中的继承时通过寄生组合式的继承。 
```js
//继承上面的类
class jsBook extends Book{
    color:string; 
    constructor(title:string,price:number,color:string){
        super(title,price);
        //添加属性，要声明
        this.color = color;
    }
}
```