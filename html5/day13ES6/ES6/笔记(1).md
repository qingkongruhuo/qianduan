# ES6
## 1、let关键字
用来定义块作用域变量
    var定义函数级作用域变量
    但是if for中定义的外部也可以访问
    可以重复定义变量
    有变量提升
    可以被window挂载
let 定义在函数内部，外部无法访问
    定义在代码块中if for等，外部也无法访问。
    不可以重复定义变量（会报错）
    无变量提升
    不可以被window挂载
## 2、const常量
const关键字定义常量
    1、无法被修改
    2、支持块级作用域
    3、无法重复定义
    4、无法声明提前
    5、不能被window挂载
    6、不能作为for循环变量使用
    7、值只能是值类型，如果是引用类型可以被修改
工作中常用大写字母来写
ES5中可以通过对象冻结技术，或者writable：false来模拟静态变量
    但问题是：对象的某个属性的值如果是引用类型依然会被改变（套娃）
ES3.1中可以用单例设计模式来模拟静态变量。在方法中只定义取值方法，不定义赋值 
    方法。
## 3、多行字符串
ES5之前单行字符串：由一组单引号或者双引号定义的字符串
    问题
        1、不能换行
        2、特殊的按键要用转义字符\n
        3、特殊符号要用转义字符\20
        4、字符串表示符号不能嵌套
        5、单引号中不能直接写单引号，要转义
        6、双引号中不能写双引号，要转义
ES6多行字符串
    通过`定义，在多行字符串中，只有 ` 需要 \`转义，其它的字符都可以直接书写
    并且ES6中多行字符串支持插值语法：${key}
    ${}提供了js环境，因此可以书写js表达式
```js
var a = 1;
var b = 2;
//多行字符串
var str = `1可以随便换行
2
3
4
4
5
插值语法:${a*b},会直接得到3，里面是js环境随便写代码`;
```
## 3、原始字符串 
字符串中有转义字符，浏览器查看结果的时候只能看到结果，不能看到原始字符串。
ES6提供了方法查看完整的原始字符串
String.raw`` 参数通过多行字符串传递，转义字符不会被转义
```js
let str = String.raw`hello \nic\nkt`
//会打印`hello \nic\nkt`
```
ES6中拓展了repeat方法用于重复输出字符串
    参数是要重复的次数，返回值是结果，对原字符没影响
```js
let str = `hello ||`
let str3 = str.repeat(3);//hello ||hello ||hello ||
```

## 4、判断字符串位置 
startsWith(str,pos) 是否以参数字符串开头
    截取后面的部分，并且包含截取位置字符
    str：参数字符串
    pos：位置
    返回值布尔值
endsWith(str,pos) 是否以参数字符串结尾
    截取前面的部分，并且不包含截取位置字符
includes(str,pos) 是否包含参数字符串
    截取后面的部分，并且包含截取位置字符
```js
let str = `这是一个神奇的课堂-爱创课堂`;
console.log(str.startWith(`这是`));//true
console.log(str.startWith(`爱创`,10));//true
console.log(str.startWith(`课堂`));//true
console.log(str.startWith(`-爱创`),12);//true
```

## 5、数字拓展
1、isNaN，判断是否是NaN，
    全局中有个isNan会进行类型转换，'123'不是NaN，但是'123abv'是NaN（Not a number）
    而Number拓展的isNaN在判断的时候不会进行转换。不是数字直接false，比如'123'.
    首先必须是数字，再去判断是否是NaN
    Number.isNaN(0/0);
2、isFinte:是否有限的，全局也有个isFinte，会做转换
    Number.isFinte不会转换 首先去判断是否是字符，然后再判断
3、isInteger 
    Number.isInteger 判断是否是整型的，首先必须是数字，然后再去判断
4、Math.cbrt：计算一个数的立方根
    Math下面有n多方法，什么log10(x)，log2(x)，sin，cous，tan。。。

## 6、字面量拓展
对象字面量：
    let obj = {}
省略语法：
    1、如果定义的属性名与属性值变量同名，我们可以省略属性名及冒号
    2、可以对属性名称书写表达式，通过[]来动态设置名称
        之前用[]获取属性，现在可以通过[]来设置属性
        []里面提供了js环境，可以写代码！！
    3、在对象中定义方法可以省略冒号以及function关键字
```js
var color = 'red';
var obj = {
    //1、如果定义的属性名与属性值变量同名，我们可以省略属性名及冒号
    color,
    // 3、在对象中定义方法可以省略冒号以及function关键字
    getColor(){
        return this.color;
    }
}
//2、可以对属性名称书写表达式，通过[]来动态设置名称
obj[price] = 100;
```

## 7、is方法
is方法用于判断两个参数是否全等
    全等的几个问题：
        0和-0全等得到true，但是它们存的地址是不同的
    NaN和NaN判断得到false，但是NaN只存了一个地址
is
    使用方法：Object.is(变量1，变量2)
    判断0和-0得到false
    判断NaN得到true

## 8、assign
ES6拓展的assign是用于复制对象的。
Object.assign(obj,obj1,obj2)
    obj被复制的目标对象，从第二个参数开始都是复制的对象，返回值是目标对象obj
    注意：后面对象中的同名属性会覆盖前面对象中的属性。
assign方法是一个浅复制
    浅：值是直接赋值，而引用类型是改变指向，没真正的赋值
    深：都是直接复制（函数除外）
实现简单深复制：将对象转成JSON字符串，然后JSON字符串再转成对象，但是这样会过滤掉函数
```js
var obj1 = {
    color: 'red',
    arr: [1,2,3]
}
var obj 2 = {
    color: 'green',
    siez: {
        width: 20,
        height: 30
    }
}
var obj3 = {
    color = 'blue',
    num: 100,
    arr: [4,5,6]
    getNum(){
        return this.num; 
    }
}
//将obj2和obj3中的属性数据 复制给obj1
var result = Object.assing(obj1,obj2,obj3)
console.log(result,obj1);//会发现result和obj1是同一个对象
//且obj3的属性如果和obj2重复会覆盖obj2的 

//浅复制：
obj1.num=500;//可以看到obj3的num属性没变
obj1.size.width=500// 连带着把obj2的width也改了！
obj1.arr[0]=200;// 连带着把obj3的arr[0]也改变了！
```
## 9、Array.from
用于遍历类数组对象，或者将类数组对象转换成数组。
    类数组对象：可以通过索引值获取属性值，并且要具备length属性。
    类数组对象不能使用数组遍历器方法，from可以将类数组对象转成真正的数组，之后就可以使用正好吃那个数组的方法。（之前遍历类数组对象都是用length属性，i<length 进行for循环遍历打印类数组对象[i]。）
Array.from(类数组对象,fn)
    fn:执行的函数，两个参数成员值和索引值，默认this默认指向window
    如果传递的fn参数，此时fn方法的返回值是函数的执行结果。
总结：from不仅可以将类数组对象转成数组，还可以遍历类数组对象。
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <div></div>
    <div></div>
    <div></div>
    <div></div>
    <div></div>
    <script>
        //获取div类数组对象
        let div = document.getElementsByTagName('div');
        //div是类数组对象，遍历
        //1、将div转成数组
        let arr = Array.from(div);
        //2、遍历类数组对象 
        let arr1 = Array.from(div,function(item,index){
            console.log(item,index);
            //返回值arr1是[0,1,2,3,4]
            return index;
        });
    </script>
</body>
</html>
```

## 10、Array.of()方法
之前用new Array()或者Array()方法创建数组有一些问题
    1、如果没有传递参数，得到的是一个空数组
    2、如果传递了一个参数，得到的是带有一个长度的空数组
    3、如果传递了一个非数字参数，得到了一个带有一个成员的数组
    4、如果传递了多个非数字参数，得到了一个带有多个成员的数组。
ES6中拓展了of方法可以实现将所有传递的参数都作为数组中的成员存在。
创建数组的四种方法：
[],new Array(),工厂方法Array,Array.of()
```js
let arr = Array.of(1,2,3)
//arr：[1,2,3]
let arr = Array.of(1);
//arr:[1]
//实现：
Array.icktOf = function(){
    return Array.prototype.slice.call(arguments);  //必须有返回值
}
```

## 11、查找数组
ES5中拓展了indexOf和lastIndexOf方法
ES6中拓展了find，findIndex
    允许参数是可以执行的函数，这样可以**定制查找方案**
        函数中有三个参数：成员值、索引值、原数组。this指向window
find方法在查找成员的时候如果找到了该成员，返回该成员，没找到返回undefined
findIndex查找成员的时候如果找到了该成员，返回该成员索引，没找到返回-1
```js
var arr = [1,2,3,4,5]
var result = arr.find(function(item,index,orign){
    //找到第一个偶数成员，下面会返回2.如果是findeIndex，会返回index。
    return item%2==0;
})
```

## 12、数组内部复制
ES6为了实现数组内部完成复制成员提供了一个方法：copyWith
arr.copyWith(pos,start,end);
    pos:要粘贴的位置（从pos位置开始复制）
    start：要复制的开始位置包含start
    end：要赋值的结束位置不含end
    返回值就是原数组，并且原数组发生变化
[0,1,2,3,4,5,6,7,8,9] copyWith(3,6,9)
[0,1,2,6,7,8,6,7,8,9]

## 13、数组迭代器方法
ES6为了遍历数组中的成员，拓展了三个迭代器方法，keys，values，entries
keys：获取索引值
values：获取成员值
entries：获取索引及成员值[index,item],是一个长度为2的数组
由于实现了数组的迭代器接口方法，就可以使用for of和next方法去遍历
    实现了迭代器接口的数据，都有next方法，可以通过next方法来遍历成员
        返回值是一个对象
            value：表示成员值
            done：表示是否遍历完
        如果遍历完了，done将永远是true，value将永远是undefined
```js
var arr = ['red','green','blue','orange','pink'];
//创建迭代器,遍历索引
var keyobj = arr.keys();
console.log(keyobj);//Array Iterator()
//遍历每一个成员
console.log(keyobj.next());//value:0,done:false
console.log(keyobj.next());//value:1,done:false
console.log(keyobj.next());//value:2,done:false
console.log(keyobj.next());//value:3,done:false
console.log(keyobj.next());//value:4,done:false
console.log(keyobj.next());// value:undefined,done:true
//创建迭代器,遍历entries
var keyent = arr.entries();
//遍历每一个成员
console.log(keyent.next());//value:Array(2),done:false
console.log(keyent.next());//value:Array(2),done:false
console.log(keyent.next());//value:Array(2),done:false
console.log(keyent.next());//value:Array(2),done:false
console.log(keyent.next());//value:Array(2),done:false
console.log(keyent.next());//value:undefined,done:true

```

## 14、for of循环
ES6 for of循环专门为实现了迭代器接口的对象设计的循环结构
    forof是专门为迭代器接口设置的遍历方法，语法 for(let item of data){}
    可以像其他循环一样在内部使用continue，break等关键字
    forof也可以遍历数组，但是在遍历的过程中无法使用索引值
        遍历数组的时候，item表示数组的每一个成员，没有办法访问索引值，但是我们可以在外部定义一个循环变量，在循环体中手动更新。for of循环遍历数组的时候，不需要通过索引值访问成员，而for循环以及forin循环要通过索引访问。
    forin也可以遍历数组，但是遍历的时候key显示的是字符串不是数组。
总结：for循环遍历数组，for in遍历对象，for of遍历实现迭代器接口的对象（包括数组）   
```js
var arr = ['red','green','blue','orange','pink'];
var keyobj = arr.values();
//for of 循环
for(let item of keyobj){
    console.log(item);
    if(item == 'blue'){
        break;
    }
} 
//迭代器接口对象一旦遍历完成，就无法再遍历了。
for(let item of keyobj){
    console.log(item);
    if(item == 'blue'){
        break;
    }
} //第二遍遍历啥也看不见 
//for of可以多次遍历数组
for(let item of arr){
    console.log(item);
} 
for(let item of arr){
    console.log(222,item);
} //第二次遍历也能遍历
//无法访问索引值，但是可以在外部定义
var index = 0;
for(let item of arr){
    console.log(222,index,item);
    index++;
}

//for in循环遍历数组的时候，会改变索引值类型。
for(let key in arr){
    console.log(typeof key,key)// string 0,string 1,...
}
```

## 16、对象解构。
所谓解构就是解构聚合数据解构
    在ES5中的聚合数据有：对象，数组
    之前，对象中获取数据的方式只能通过点语法或者中括号语法，数组只能用中括号语法。
ES6中简化了获取数据的方式，提供了解构语法：对象解构与数组解构。 

对象解构：
    语法：let{key1,key2,...keys} = obj;
    **相当于let key1 = obj.key1**
    key1相当于obj.key1,key2相当于obj.key2
    keys获取的是剩余属性，如果没有剩余属性，获得到的是一个空对象。
    注意：结构出来的属性，变量一定是和对象中的属性是同名的。
解构问题：
    1、如果用var解构，会污染全局对象window，可以用let解决
    2、解构出来的方法，方法中的this会发生改变
    3、对于引用数据类型来说，只是指向的改变，对于值类型来说，是真正的复制   
逆运用：我们可以通过三个点语法，将一个对象中的所有数据传递给一个对象字面量中：
    {...keys}

    由于结构出来的数据会创建全局变量，因此工作中常常配合模块化开发使用（相当于局部变量。）
```js
var obj = {
    num: 100,
    color: 'red',
    arr:[1,2,3],
    age: 18,
    id: 110
}
//结构：
let{num,color,arr,...other} = obj; 
console.log(num,color)//num=100，color=’red‘
console.log(other)//other{age: 18,id: 110}
//问题3和之前浅复制相同
obj.arr[0] = 100;
console.log(arr[0]);//100

//结构语法可以拿来浅复制对象。
let{...newObj} = obj
//结构反向运用
var newObj2 = {num,color,arr,...other} 
```

## 17、数组解构
let[item1,item2,...itmes]=arr
arr表示数组
item1=arr[0],item2=arr[1],items为剩余元素的数组
获取剩余成员的语法items
    1、若数组中没剩余成员，items为空数组
    2、有剩余成员，items数组中的成员为arr中的全部剩余成员
```js
var arr = ['red','green','blue','orange','pink'];
//数组解构
let[red,green,...items] = arr;
console.log(red,green,items)//'red','green',Array(3)
//复制数组，解构逆运用
var newArr = [red,green,...items];
var newArr1 = [red,...items,green]
```

## 18、函数拓展：默认参数
之前适配默认参数的方式：
    1、可以通过||运算符来适配参数的默认值
        但使用||会忽略6个值为false的参数：0，``，undefined，null，false，NaN
    2、可以使用三元运算符？如果参数过多，书写比较麻烦
    3、使用extend|assign方法适配对象，对于值类型的参数不适用
ES6为了解决这样的问题，提供了适配默认参数的方法，直接在参数集合中为形参赋值即可
function fn(形参 = 默认值){

}
    如果传递了参数，则使用传递的参数
    如果没有传递参数，则使用默认参数
ES6拓展的适配默认参数的方式与三元运算符的方式是等价的。
```js
function demo(color){
    //设置red为默认参数
    // //1、||适配
    // color = color||'red';
    // //2、三元运算符,如果参数很多，会特别麻烦
    // color = color === undefined? 'red'
    //3、assign
    console.log(color);
}
//执行函数并传递参数
demo(0);
demo(false);
demo('');
demo(NaN)
dmeo('green');
//4、ES6与三元运算符的方式是等价的。 只要数据不是undefined，都能获取到
function demo1(color = 'red'){
    console.log(color);
}
demo1(0);
demo1(false);
demo1('');
demo1(NaN)
dmeo1('green');
```

## 18、获取默认参数
之前用arguments，但是它是类数组对象不太方便，于是ES6中拓展了获取剩余参数的语法.

function demo(arg1,arg2,...args){
    arg1表示第一个参数，arg2表示第二个参数，args表示剩余参数
}
注意：
    1、如果有剩余参数，args表示数组
    2、如果没有，得到空数组
    3、前面参数可以正常使用，如果没传参数，arg1和arg2都是undefined，就是说传了几个arg就定义几个
    4、在箭头函数中有广泛应用 
逆运用：
    **demo(...args)**,非常好用！把数组作为参数传到函数中
    我们可以将一个数组中的成员，作为参数传递到一个方法中。
    之前是用apply
```js
function add(...items){
    return items[1]+items[2];
}
var arr = [1,2,3,4]
//ES6之前
var res = add.apply(null,arr)
//ES6之后
let result = add(...arr);
```

## 19、箭头函数
1、函数定义式
function demo(){}
2、函数表达式
let demo = function(){}
3、构造函数式
let demo = new Function('console.log(" hi")')
4、箭头函数
    语法：
        let demo = () =>{}  
    ():参数集合
    =>：箭头函数标志
    {}：函数体
    简化：
        1、如果参数集合只有一个参数，可以省略参数集合
            要是...语法获取剩余参数不能省略！
        2、如果函数体只有一句话，或者只有返回值，可以省略return以及函数体 
```js
//省略1
let demo = msg => {
    return msg;
}
//省略2:求arr平方和
var arr = [1,2,3,4,5]
let res = arr.map(function(item){
    return item*item;
})
let result = arr.map(item => item*item);

```

箭头函数特点：
    1、无法使用arguments，但是可以通过...来获取剩余参数
    2、无法作为构造函数来使用，其实是因为this
```js
function Player(x,t){
    this.x = x;
    this.y = y;
}
//以后都这么给原型加方法，可以把很多方法写在一起，而且不会覆盖constructor方法
Object.assign(Player.prototype,{
    getPosition(){
        return x+' '+y,
    }
})
```
3、this指向永远是**定义时**的（其它函数是**执行时**的，也就是谁调用，this是谁）
        无论call，apply，bind都无法更改箭头函数this指向
        改变箭头函数this指向的唯一方法就是改变其宿主环境作用域
        也就是说改变其外部函数的作用域
```js
'use strict'
console.log(this);
let demo = () =>{
    console.log(this);
}
demo();//哪怕是严格模式，还是打印window 

```
https://www.cnblogs.com/dongcanliang/p/7054176.html

**题外话：严格模式影响的函数是全局函数，不影响对象内部的函数**
## 20、箭头函数this指向
由于箭头函数不绑定this， 它会捕获其所在（即定义的位置）上下文的this值，作为自己的this值，
    1、所以 call() / apply() / bind() 方法对于箭头函数来说只是传入参数，对它的 this 毫无影响。
    2、考虑到 this 是词法层面上的，严格模式中与 this 相关的规则都将被忽略。（可以忽略是否在严格模式下的影响）
    3、箭头函数在函数或方法内部，this指向这个函数或者方法，即父函数或方法的this，
    4、箭头函数作为方法使用时，this指向window，如下例子。（方法：对象内部定义的函数，通过对象名.方法名来调用的）
```js
var obj ={
            color: 'red',
            fun1: function(){
                var fun2 = () =>{
                    console.log(this);
                }
                fun2();
            },
            fun3: ()=>{
                console.log(this);
            }
        }
        obj.fun1();//obj
        obj.fun3();//window
```
## 21、数据类型拓展Symbol
js中有六种数据类型：number string boolean undefined，null，对象
Es6新增了Symbol数据类型，表示独一无二的数据
    我们可以通过Symbol方法创建Symbol数据，参数就是对Symbol数据的描述，但是结果不受影响。
    我们可以通过typeof查看Symbol的数据类型，如果参数传递的是对象，默认会调用其toString
方法。
```js
let s1 = Symbol();
let s2 = Symbol();
let s3 = Symbol('zhang');
let s4 = Symbol('zhang');
console.log(typeof s1);//symbol
s1==s2//false
s3==s4//false
//参数是对象
let obj = {
    color:'red',
    //会默认调用toString方法，下面重写
    toString(){
        return 'helloworld';
    }
}
let s5 = Symbol(obj);//Symbol(helloworld)
```
Symbol数据类型的出现是为了避免对象中同名属性被覆盖的问题，比如你想往jquery库中添加一个方法，但是你不知道原来里面有没有，这时候就可以用symbol
    我们通过Symbol创建的数据类型，就可以避免对象中同名属性被覆盖的问题,
    Symbol创建的数据不能通过for in 的方式查看，也不能通过Object.keys去查看数据
    只能通过Object.getOwnPropertySymbols查看数据（Object.keys(对象)用来获取对象中所有属性数据的，返回值为一个数组里面是全部属性名。）
    还可以通过变量，查看对应的数据类型。
```js
var obj = {
    color: 'red',
    price: 100
}
//如果直接用obj.color='green'添加同名属性会覆盖
//可以添加symbol属性
let s1 = Symbol('color');
obj[s1]='green';
console.log(obj)//
                // {color: 'red', Symbol(color): 'green'}
                // color: "red"
                // Symbol(color): "green"
                // [[Prototype]]: Object
//访问Symbol属性,1、通过key
obj[s1]
//2、获得Symbol的keys数组，forEach遍历
var keys = Object.getOwnPropertySymbols(obj);
keys.forEach(key=>console.log(obj[key]));
```
Object.keys:获取自身属性，不包括不能枚举的和symbol
Object.getOwnPropertySymbols:获取自身symbol属性，不能获取自身属性和设置特性的属性
Object.getOwnPropertyNames:获取自身属性，包括不能枚举的，不包括symbol

## 22、代理
在一个系统中，总要在一个对象中存储一些数据，对于这些数据，可能有一些是希望我们访问的，但是总有一些是重要的，不希望我们访问的，希望保护起来，因此ES6新增了代理，实现这一特征。
**代理就是通过一个对象来保护另一个对象**
语法：通过Proxy实现：let proxy =  new Proxy(obj,{set,get})
    第一个参数：obj表示被代理的对象
    第二个参数：{set,get}表示操作被代理对象的对象
        get(obj,key)表示取值的方法
            obj表示被代理对象，key表示获取的属性名
            返回值很重要：就是获取的数据，this指向操作对象。
        注意：这里决不能获取代理对象proxy的key属性 

        set(obj,key,value)表示赋值的方法
            obj表示被代理的对象，key表示修改的属性，value表示修改的属性值
            this指向操作对象，不需要返回值
        注意：绝对不能再里面修改代理对象proxy的key属性
    代理和特性很像
        特性是对同一个对象的操作，数据不能再当前属性中存储，存储在备份中
        代理是对不同的对象的操作，数据可以直接存储在当前属性下，原对象属性可以发生改变。
        代理是一个对象保护另一个对象，特性是对象自身属性的自我保护？

```js
let star = {
    name1: 'zhang'
    girlfriend: 'liu'
}
//代理
var proxy = new Proxy(star,{
    //取值器方法
    get(obj,key,proxy){
        //console.log(this,arguments) this指向proxy，arguments[0]:star,arguments[1]:key
        //不想让外界获取girlfriend信息，
        if(key=='girlfriend'){
            return '这是个秘密';
        }
        return obj.name;
    },
    //赋值器方法  
    set(obj,key,value,proxy){
        //console.log(this,arguments) this指向proxy,arguments[0]:star,arguments[1]:name1,arguments[2]:'帅哥'
        //不想让外界更改girlfriend信息
        if(key=='girlfriend'){
            return ;
        }
        bbj[key]=value;
    }
});
proxy.name1;//zhang
proxy.girlfriend//这是个秘密
propxy.name1='帅哥'
proxy.girlfriend = '刘文婷'//修改失败
```

## 23、Reflect
Reflect是对对象中一些操作方法的封装。
在之前，对象中的所有方法都给了Object，这些方法都属于内部语言方法，于是这些方法拿出来给了Reflect，因此再次调用这些方法的时候，就可以通过Reflect来调用了。
所以，在未来对象中的方法可能被移除，给了Reflect，例如
    之前定义特性的方式：Object.defineProperty,现在定义特性的方式：Reflect.defineProperty
Reflect允许对一些操作符当做方法去执行
    has：代替in运算，检测某个属性是否存在，
    deleteProperty：删除对象中的某个属性
    getOwnPropertyDescriptor：获取某个属性的描述特性对象
    get:获取数据
    set设置数据  
```js
let obj = {
    color: 'red',
    num: 100
}
// //ES5设置特性，不想让color被枚举
// Object.defineProperty(obj,'color',{
//     enumerable:false ;
// })
//ES6设置特性，不想让color被枚举
Reflect.defineProperty(obj,'color',{
    enumerable:false ;
})
//修改color
obj.color = 'green';
for(let key in obj){
    console.log(key,obj[key ]);
}
//判断对象是否具有某个属性
'clolr' in obj;
//es6
Reflect.has(obj,'color');
//删除属性
Reflect.deleteProperty(obj,'color')
```

## 24、set和weakset
ES6新添加了四种聚合数据，Set WeakSet Map WeakMap （对象数组原来就有）
var set = new Set(1,2,3,4,4,5,'4')
Set是实现了迭代器接口的去重数组
    在去重的时候不会做类型转换
    因为实现了数组迭代器接口，可以使用for of语句遍历该对象
提供了大量方法操作该对象
size:长度
has:判断是否包含某个元素
add：
delete
clea
forEach
    set.forEach(item=>{console.log(item)})
keys，values，entriex是用于获取迭代器接口,因为set没有key，所以set.keys和set.values获取到的迭代器对象是一样的。同理entries里面的key和value也一样 

**数组去重**，建议多掌握几种方式
```js
var arr = [1,2,2]
//用Set去重
var set = new Set(arr);
//将set对象转成数组，用...语法
arr = [...set]
```
weakSet：弱set对象，成员只能是引用类型数据（比较地址），不能添加空对象null，
只有add，delete和has三个方法，
不能被垃圾回收机制自动回收，慎用

## 25、Map和WeakMap 
Map是一个超对象
    **传统的对象所有属性名称都必须是字符串**
    但是在Map中，定义的属性名称可以是任意类型
    通过new Map创建map对象，实现了迭代器接口，因此可以使用for of循环
内部也提供了大量的方法用于操作该对象，
    size
    has
    delete
    get获取数据
    set设置数据
    forEach
    keys、values、entries获取迭代器接口
WeakMap是弱map对象，属性名只能是引用类型的数据。
    方法还剩delete，has，get set

## 26、迭代器接口
ES6中只实现了迭代器接口（Symbol.iterator）并没有实现迭代器接口类，有四种情况会实现迭代器接口
    1、 使用迭代器接口方法的时候，如keys，values，entries
    2、在解构的时候
    3、创建map，set
    4、for of循环
迭代器的作用：
    1、定义了我们访问数据的次序，
    2、为for of 提供了访问数据的方式
    3、让所有数据具备统一的接口，方便而快捷的获取数据    
类数组对象实现了迭代器接口，对象没有实现
```js
//自定义类数组对象
var arrLike ={
    0:'red',
    1:'green',
    //定义length属性
    length: 2,
    //为了使用for of循环，要实现迭代器接口
    [Symbol.iterator]: Array.prototype[Symbol.iterator] 
}
for(let item fo arrLike){
    console.log(item);
}
```

## 27、Promise
Promise是将异步写法变为同步写法的规范
    只是写法的改变，操作并没有改变
    同步操作：将方法写在外部
    异步操作：在回调函数中，一层一层嵌套，比如setTimeout的回调函数里还可以再嵌套一层setTimeout，就很混乱了

    Promise就把异步写法改成了同步的写法
```js
//同步操作
function demo(){
    console.log('demo run')
}
demo();
console.log('next')
//demo执行完才打印next，没执行完不能打印

//异步操作
setTimeout(()=>{
    console.log('demo run');
    setTimeout(()=>{
        console.log('demo run2')
    },1000)
},1000)
console.log('next')//next先被打印出来，这是异步的
```
三个状态
    pending：表示操作正在执行
    resolved：表示操作执行成功
    rejected：表示操作执行失败
状态的流向：
    在Promise中状态有两个方向的流动：
        有pending流向resolveed说明操作执行完毕
        由pedning流向rejected，说明操作执行失败完毕

Promise规范：
    语法：new Promise((resolve,reject)=>{回调函数中执行异步操作})
        如果操作成功，执行resolve方法，如果失败执行reject方法
    在外部通过then监听状态的改变
        then(success,fail)
            success：表示成功的时候执行的回调函数，参数由resolve方法执行的时候传递的参数（只能传递一个）
        fail：表示失败时候执行的回调函数，参数是由reject方法执行的时候传递的参数（只能传递一个）
    then方法的返回值是Promis对象，因此可以链式调用该方法。
    上一个then方法的返回值 ，将作为下一个then方法的输入，如果操作已执行完毕，then方法也会立即执行。
```js
//异步操作
let p = new Promise((resolve,reject)=>{
    //处理异步
    setTimeout(()=>{
        //成功
        resolve('操作成功',100,200)
        //失败执行reject
        // reject('执行失败')
    },1000)
})
//监听结果
p.then(
    //成功的回调函数
    (...args)=>{
        //只能接收resolve传过来的第一个参数
        console.log('success',args);
        return 'success'
    },
    //失败的回调函数
    (...args)=>{
        console.log('fail',args);
        return 'fail'
    }
    //then返回值是Promise对象，所以可以链式调用
).then(
    (...args)=>{
        console.log('第二次执行成功',args)
    },
    (...args)=>{
        console.log('第二次执行失败',args)
    }
)
console.log(p)//可以看到p执行的状态
```

Promise提供了几个方法可以监听Promise状态
    1、then可以监听状态成功或者是失败的方法
    2、catch：可以监听状态失败时候的方法
        失败只能被监听一次，但是后面还可以被then监听到
```js
//异步操作
let p = new Promise((resolve,reject)=>{
    //处理异步
    setTimeout(()=>{
        //失败执行reject
        reject('执行失败')
    },1000)
})

p
    //监听失败
    .catch(err=>console.log(err))
    //虽然catch只能用一次，但是后面还可以被then监听到
    .then(
    //成功的回调函数
    (...args)=>{
        //只能接收resolve传过来的第一个参数
        console.log('success',args);
        return 'success'
    },
    //失败的回调函数
    (...args)=>{
        console.log('fail',args);
        return 'fail'
    }
    //then返回值是Promise对象，所以可以链式调用
)
```
    3、finally：无论成功还是失败都会执行的方法
        不能接收数据，即reject和resolve传来的数据都接收不到
        finally后面还可以被then监听到


Promise.all()方法用于监听多个Promise对象，Promise的静态方法
    参数是一个数组，每一个成员都是一个Promise对象
我们可以通过then方法监听状态的改变
    如果所有操作都执行成功，才会执行success方法
    如果有一个操作执行失败，则会直接执行fail方法，不会等后面的promise对象了。
    不论成功还是失败，返回值都是一个数组，数组中的每个成员对应每一个promise返回的数据。
```js
//第一个异步操作
var p1 = new Promise((resolve,reject)=>{
    setTimeout(()=>{
        //成功
        resolve('第一个异步操作执行完毕')
    },1000)
})
var p2 = new Promise((resolve,reject)=>{
    setTimeout(()=>{
        //成功
        resolve('第二个异步操作执行完毕')
    },200)
})
//都执行完毕，打印success
Promise.all([p1,p2])
    //监听结果
    .then()
        //成功的回调函数
        data=>console.log('全成功了',data),
        //失败的回调函数
        data=>console.log('有一个失败了',data),
    )
```
Promise.race()方法也是监听多个Promise对象，使用方法和all一模一样
    如果有一个操作执行成功，则会直接执行success方法，不会等后面的promise对象了
    如果全部操作执行失败，会直接执行fail方法。

Promise.resolve()是Promise的静态方法，返回一个可以监听resolved状态的promise对象。
    参数由三种：
        js数据，此时then方法会立即执行（then方法接收的数据就是该数据）
        promise对象
        thenable参数（带有then方法的对象）
```js
//定义promise(第一种参数js数据)
var p1 = Promise.resolve(100);
//监听结果
p1.then(
    //成功的回调函数
    data=>console.log('success',data),//data就是100，上面传过来的js数据 
    //失败的回调函数
    data=>console.log('fail',data),
)

//定义promise(第二种参数promise对象)
var p = new Promise((resolve,reject)=>{
    setTimeout(()=>{
        //成功，当然也可以写失败reject()，then也接收得到
        resolve('第一个异步操作执行完毕')
    },1000)
})
var p2 = Promise.resolve(p);
//监听结果
p2.then(
    //成功的回调函数
    data=>console.log('success',data),//data就是'第一个异步操作执行完毕', 上面传过来的js数据 
    //失败的回调函数
    data=>console.log('fail',data),
)

//定义promise(第三种参数thenable对象)
var p3 = Promise.resolve({
    color: 'red',
    //then方法
    then(resolve,reject){
        setTimeout(()=>{
        //成功
        resolve('第一个异步操作执行完毕')
        },1000)
    }
});
//监听结果
p3.then(
    //成功的回调函数
    data=>console.log('success',data),//data就是'第一个异步操作执行完毕', 上面传过来的js数据 
    //失败的回调函数
    data=>console.log('fail',data),
)
```

reject也是Promise的静态方法，返回一个可以监听rejected状态的对象。
    then方法监听失败的时候，回调函数的参数就是reject方法参数（错误的描述信息）
    **不论reject方法是什么数据，then都将执行失败的回调函数**。
```js
//定义promise(第二种参数promise对象)
var p = new Promise((resolve,reject)=>{
    setTimeout(()=>{
        //成功，当然也可以写失败reject()，then也接收得到
        resolve('第一个异步操作执行完毕')
    },1000)
})
var p2 = Promise.reject(p);
//监听结果
p2.then(
    //成功的回调函数
    data=>console.log('success',data),
    //失败的回调函数
    data=>console.log('fail',data),// 虽然上面是resolve，但是这个只能监听到失败，不管数据，就是失败
)
```

## 28、generator函数
generator函数为处理异步编程提供了解决方法（异步函数），内部封装了大量的状态，允许我们逐条遍历。
function *demo(){函数中定义的状态}
    在函数内部通过yield关键字定义状态，yield表示暂停的意思。
        注意：**yield关键字只能出现在generator函数中,外面用会报错**
    通过return定义最后一个状态，return后面的状态不会执行。
generator函数的返回值实现了next方法，因此可以通过next方法逐条遍历内部的状态。
    next方法的返回值是一个状态对象
        done属性：表示是否遍历完成
        value属性：表示状态值
        如果有状态的情况，done是false，value是状态值
        如果没状态，此时done是true，value是undefined
generator函数的返回值也实现了迭代器接口，因此可以通过for of方式遍历内部的状态。
    但是不要同时使用两种方式遍历内部的状态
    因为一方遍历完了，另一方就得不到状态了。
当generator函数遍历完成时，此时它的状态变为closed
当generator函数没有遍历完成时，它的状态变为suspended
```js
//generato函数就是在普通函数名称前面加一个*
function *demo(){
    console.log('hello');
    //定义状态
    yield '起床';
    yield '吃饭';
    yield '上课';
    return '睡觉';//return 是最后一个状态 
}
//执行
demo()//但是并不会出现什么，要通过next方法来遍历状态
var g = demo();
console.log(g.next());
//第一次执行，打印hello，打印起床 done：false
console.log(g.next());//打印吃饭 done：false
console.log(g.next());//打印上课 done：false
console.log(g.next());//打印睡觉 done：true
console.log(g.next());//undefined done：true。
//想要再次遍历，要重新执行
var g2 = demo();
console.log(g2.next());
console.log(g2.next());
console.log(g2.next());
console.log(g2.next()); 

//可以用for of去遍历，因为实现了迭代器接口
//注意for of循环不会遍历到return后面的最后一个状态
var g3 = demo();
for(let item of g3){
    console.log(item)
}
```
generator函数可以把异步变成同步的！
```js
function *demo(){
    yield setTimeout(()=>console.log(111),1000);
    yield setTimeout(()=>console.log(222),2000);
    yield setTimeout(()=>console.log(333),3000);
}
//执行
var g = demo();
g.next()//只会打印11，因为遇到一个yield就停了，想继续执行还要g.next
```

## 29、generator函数的数据传递
在generator函数中数据传递有两个方向
    1、数据由generator函数内部流向外部
    2、数据由外部流向内部
数据由内部流向外部
    第一步：通过yield表达式定义状态值
    第二步：在外部通过next方法返回的对象中的value属性获取
```js
function *demo(){
    yield 'red';
    yield 'blue';
    yield 'green';
    return 'gray';
}
var g = demo();
//获取内部状态
console.log(g.next().value);
console.log(g.next());
console.log(g.next());
```
数据由外部流向内部
    第一步：在外部通过next方法传递数据
    第二步：在内部通过yield表示接收数据
```js
function *demo(num1){
    console.log(1,num1);//111只有当第一次调用next方法才能拿到，因为var g = demo(111)只是初始化而已，第一次执行next方法相当于从函数开始执行到第一个yield并暂停
    var num2 = yield 'red';
    console.log(2,num2);//2，222
    var num3 = yield 'blue';
    console.log(3,num3);//3,333
    var num4 = yield 'green';
    console.log(3,num3);//4,444
}
var g = demo(111);
//给方法传递数据，可以在内部接收数据
console.log(g.next())//第一次使用next是启动，不能传递数据，可以用demo去传递数据
console.log(g.next(222));
console.log(g.next(333));
console.log(g.next(444 ));
//demo执行相当于初始化，第一个next相当于启动，后面的next开始正常了。
```

## 30、generator的reutrn和throw方法
return
    在generator函数的原型中提供了reutrn方法，用于在外部停止内部状态的遍历。
    如果在函数体中**实现了finally语法，return语句将会延后执行。**

```js
function *demo(){
    try{
        yield 1;
        yield 2;
        yield 3;
    }catch(e){
        yield 4;
        yield 5;      
    }finally{
        yield 6;
        yield 7;
    }
    yield 8;
    yield 9;
    return 10;
    //return表示内部语句运行完毕，下面不会继续运行了
    yield 11;
    yield 12;
} 
var g = demo();
console.log(g.next());
console.log(g.next());
console.log(g.next());
console.log(g.next());
console.log(g.next());
console.log(g.next());
console.log(g.next());
console.log(g.next());
console.log(g.next());
console.log(g.next());
//执行顺序：1 2 3 6 7 8 9 10
```
```js
function *demo(){
    try{
        yield 1;
        yield 2;
        yield 3;
    }catch(e){
        yield 4;
        yield 5;      
    }finally{
        yield 6;
        yield 7;
    }
    yield 8;
    yield 9;
    return 10;
    //return表示内部语句运行完毕，下面不会继续运行了
    yield 11;
    yield 12;
} 
var g = demo();
console.log(g.next());
console.log(g.next());
console.log(g.return(100))//return后，传递的数据就是value值，而且后面done。而finally里面的外码无论如何都会执行的，而且如果有finally，return会延后到finally执行结束才会打断
console.log(g.next());
console.log(g.next());
console.log(g.next());
console.log(g.next());
console.log(g.next());
console.log(g.next());
console.log(g.next());
console.log(g.next());
//1,2,6，7100,下面全是undefined和done

```
throw
    在generator函数的原型中提供了reutrn方法，允许在外部抛出错误
    为了代码正常执行，我们可以在状态函数体重通过try catch语句去捕捉错误
    如果外部抛出两个错误：
        第一个错误在状态函数体重通过try catch语句去捕获第一个错误
        第二个错误在状态函数外部通过trycatch语句去捕获第二个错误
懒得看了

## 31、generator函数的yield*语法
yield* 语法
    可以将函数内部的状态赋值到另一个函数体中执行
```js
function *demo(){
    yield 1;
    yield 2;
}
//执行demo
var g = demo();
//查看状态，next或者for of，这次用三个点语法。
console.log(...g)//1 2，一次将全部状态全遍历完了
//状态一旦遍历完就再也遍历不到了

function *ickt(){
    yield 3;
    yield 4;
    //想把状态1和2拿进来，除了手写，还可以用yield*语法
    yield* demo();
}
var g2 = ickt();
console.log(...g2)//3 4 1 2,状态12就拿进来了
```
三个点语法
    使用三个点语法结构的时候，可以将一个状态函数体重的所有状态值取到。
generator函数中的this**generator不能作为构造函数去用**
    指向window，所以千万不能通过this去添加任何属性及方法
    如果想要添加属性或者方法，我们可以在函数执行的时候，用call或者apply方法改变其作用域将指向函数的原型

    generator函数比较特殊，原型方法可以被generator创建的对象直接使用。
    （var d = demo(),d就可以调用原型上的方法，普通函数只能通过实例对象去调用原型上的方法。）
```js
function *demo(){
    yield 1;
    yield 2;
    this.color = 'red';
}
//为了让函数中的this指向generator函数创建的对象，可以在原型对象上执行。因为原型方法属性可以被generator创建的对象直接使用
var d = demo.call(demo.prototype);
d.next();
d.next();
d.next();
console.log(d.color)//执行两次next的原因是，只有俩yeild过完才能到给this.color赋值red
```

## 32、generator函数处理串行异步操作
Promise.all()可以处理并行的异步操作
串行：异步操作一个接一个执行，彼此之间有依赖关系，后一个执行依赖前一个执行的结果,时间是各个操作时间总和（并行时间是时间最长的那个）
```js
//定义三个异步操作
var task1 = (data) => new Promise((resolve,reject)=>{
    setTimeout(()=>{
        console.log('task1',data);
        resolve('第一个执行完毕')
    },1000)
});
var task2 = (data) => new Promise((resolve,reject)=>{
    setTimeout(()=>{
        console.log('task2',data);
        resolve('第二个执行完毕')
        //reject(’第二个执行失败‘)
    },2000)
})
var task3 = (data) => new Promise((resolve,reject)=>{
    setTimeout(()=>{
        console.log('task3',data);
        resolve('第三个执行完毕')
    },3000)
});
//借助generator函数实现串行
function *demo(result){
    //定义暂停状态，执行异步操作
    console.log('start');
    //执行第一个异步操作
    result = yield task1(result);
    console.log('inner111',result);
    //执行第二个异步操作
    result = yield task2(result);
    console.log('inner222',result);
    //执行第三个异步操作
    result = yield task3(result);
    console.log('inner333',result);
    console.log('end');
}
 
 //开始传递个数据给task1，task1执行完的结果给task2...
 //因为yeild的存在，不会同时执行的，这样就以串行的操作来串起来了
 //执行操作

 var d = demo('操作开始了');
 //监听第一个操作的执行完毕
 d.next().value.then((data)=>{
    console.log('监听第一个操作结果',data);
     //将第一个操作的结果给第二个操作去运行
     //监听第二个操作的结果
    d.next(data).value.then(
        //监听成功
        (data)=>{
            console.log('监听第二个操作结果',data);
            //将第二个操作的结果给第三个操作去运行
            //监听第二个操作的结果
            d.next(data).value.then((data)=>{
                //监听第三个操作的结果
                console.log('监听第三个操作结果',data);
            }）
        },
        //监听第二个失败
        (err) =>{
            console.log('outer监听第二个失败',err);
            //监听第三个操作，并传递数据
            d.next(data).value.then((data)=>{
                //监听第三个操作的结果
                console.log('监听第三个操作结果',data);
            }）
        }

        
    )
 })

```
每一个操作都有成功失败，成功失败分别要再向下写，大概到第三个操作已经写了8个高度重复的代码块了。非常之麻烦，所以有人提供了co模块

通过co工具快速启动并监听结果,先导包从var d开始到下面全可以不要了
```html
<script src='co.js'>
co(demo,'操作开始了')
    .then(
        //成功
        data=>console.log('success',data),
        //失败
        err=>console.log('fail',err)
    )
```

## 33、async与await(重点，面试会问!)
这俩货是ES7提出的
    可以认为是generator的语法糖
        语法糖：对一些复杂操作的简化，可以使我们用更简单的方式去操作，提高了开发效率
async表示函数中有异步操作，代表了*语法
await表示等，只有当程序执行完毕时，后续代码才会执行，代表了yeild的关键字。
特点：
    1、提高了代码的语义化
    2、await返回值是promis对象
    3、await后面允许是任何数据
    4、在函数中内置状态函数的启动，直接执行函数即可，**不需要通过next方法执行**
        generator 是手动来的，async是自动的
    5、generator表示状态机，async定义的是异步函数

```js
function demo(){
    console.log('start');
    new Promise(resolve =>{
        setTimeout(()=>{
            console.log('success');
        },1000);
    })
    console.log('end');
}
//会先打印start，然后end，然后success
//因为setTimeout是异步的

//怎样让异步函数同步执行？可以使用如下方法
//使用异步函数
async function demo1(){
    console.log('start');
    //等一等,等异步操作执行完毕再向下执行
    await new Promise(resolve =>{
        setTimeout(()=>{
            console.log('success');
        },1000);
    });
    console.log('end');

}
//start 1秒后执行success，end

//用异步函数代替状态函数*写成async，yield携程await
//异步函数的执行和普通函数一样，await返回的是promise对象
//定义三个异步操作
var task1 = (data) => new Promise((resolve,reject)=>{
    setTimeout(()=>{
        console.log('task1',data);
        resolve('第一个执行完毕')
    },1000)
});
var task2 = (data) => new Promise((resolve,reject)=>{
    setTimeout(()=>{
        console.log('task2',data);
        resolve('第二个执行完毕')
        //reject(’第二个执行失败‘)
    },2000)
})
var task3 = (data) => new Promise((resolve,reject)=>{
    setTimeout(()=>{
        console.log('task3',data);
        resolve('第三个执行完毕')
    },3000)
});
async function demo(result){
    //定义暂停状态，执行异步操作
    console.log('start');
    //执行第一个异步操作
    result = await task1(result);
    console.log('inner111',result);
    //执行第二个异步操作
    result = await task2(result);
    console.log('inner222',result);
    //执行第三个异步操作
    result = await task3(result);
    console.log('inner333',result);
    console.log('end');
}
demo2()
    .then(
        //成功
        data => console.log(data),
        err => console.log(err)
    )
```

## 34、程序控制权
当程序执行到await时，会交出程序的控制权，只有当异步操作执行完毕后，后续的代码才会执行
    如果await后面出现了其他数据，会返回一个监听resolved状态的promise对象
    如果函数中出现了错误，会将错误信息追踪到错误队列中
返回对象
    await返回值时一个promise对象
        可以使用then方法去监听成功的状态
        可以用catch方法监听失败的状态
    await与yiedld一样
        await只能出现再async中，
        yield只能出现再generator中
```js
async function demo(){
    console.log('start');
    await 100;
    console.log('end');
}
demo();
console.log('outer')
//先执行start，然后遇到await交出程序控制权，向下执行打印outer，然后end

//面试题======================================
setTimeout(function(){
    console.log(111);//最后执行脱离程序的异步
},0)
var p = new Promise(resolve=>{
    console.log(222);//同步1，其实promise是同步模拟的
    resolve();//异步，要给then去执行
})
p.then(
    data=>console.log(333)//监听同步1完成才能运行，
)
let demo = async function(){
    console.log(444);//同步2
    await 100;//异步，交出控制权
    console.log(555);
}
demo().then(data=>console.log(666));//监听demo执行结束才会执行
console.log(777);//同步3
//2 4 7 3 5 6 1
//面试题======================================
setTimeout(function(){
    console.log(111);
},0)
let demo = async function(){
    console.log(444);
    await 100;//await 100等价于 var result = await Promise.resolve(100)
    console.log(555);
    await 100;
    console.log(888);
    await 100;
    console.log(999);
}
demo().then(data=>console.log(666));
var p = new Promise(resolve=>{
    console.log(222);
    resolve();
})
p.then(
    data=>console.log(333)
).then(
    data=>console.log('aaa')
).then(
    data=>console.log('bbb')
)
console.log(777);
//4 2 7 5 3 8 aaa 9 bbb 6 1
```

## 35、类
ES6实现了类，语法 class 类名{}
ES6之前定义类的方法:function 类名(title){this.title = title}
在类体中可以定义三类数据
    1、实例数据
        可以通过constructor构造函数定义自身属性或者方法，这类数据会被当前实例化对象访问
    2、原型数据
        我们直接在类体中定义原型方法即可
        如果要定义原型属性数据，必须使用get、set设置特性的方法来定义
        由于对数据设置了特性，在查看对象的时候这些数据将展示在自身
    3、静态数据，通过了类直接访问，而实例化都西昂不能访问
        定义静态数据的方法：
            1、直接在类体中，在数据的前面加上static关键字
            2、在类体外部直接添加数据
                区别：在类体中添加静态数据设置了特性，而在类体外部添加静态数据没设置特性
    注意：每一个实例都会存储一份独立的数据
```js
class Book{
    //构造函数
    constructor(title,price){
        //实例属性
        this.title = title;
        this.price = price;
        this.colors = ['red','green']
    }
    //原型方法
    getTitle(){
        console.log(this.title);
    }
    getTitle(){
        console.log(this.title);
    }
    //原型属性,因为设置了特性，在实例上面也能看得到，以...的方式
    get num(){
        return this._num;
    }
    set num(val){
        this._num = val; 
    }
    get arr(){
        return this._arr;
    }
    set arr(val){
        this._arr = val; 
    }
    //静态数据
    static get writer(){
        return 'zhang';
    }
    static getWriter(){
        return this.writer;
    }

}
//实例化
var b1 = new Book('java',59);
var b2 = new Book('java',60);
b1.colors===b2.colors//false，每一个实例都会存储一份独立的数据
b1.arr = [1,2,3]
console.log(b2.arr)//undefined,每一个数据都是存在实例上的，其它实例读取不到
//外部添加静态数据,实力对象访问不到
Book.msg = 'hello'
Book.getMsg = function(){
    return this.msg;
}
```

## 36、继承
extends
```js
class Book{
    //构造函数
    constructor(title,price){
        //实例属性
        this.title = title;
        this.price = price;
        this.colors = ['red','green']
    }
    //原型方法
    getTitle(){
        console.log(this.title);
    }
    getTitle(){
        console.log(this.title);
    }
    //原型属性,因为设置了特性，在实例上面也能看得到，以...的方式
    get num(){
        return this._num;
    }
    set num(val){
        this._num = val; 
    }
    get arr(){
        return this._arr;
    }
    set arr(val){
        this._arr = val; 
    }
    //静态数据
    static get writer(){
        return 'zhang';
    }
    static getWriter(){
        return this.writer;
    }

}
//继承
class JsBook extends Book{
    //重写属性方法
    //重写构造函数
    constructor(title,price,num){
        //通过super关键字实现构造函数的继承
        super(title,price);
        //写新的属性
        this.score = num;
    }
    //原型属性
    get time(){
        return 2019;
    }
    get Time(){
        return '2019'
    }
    //静态
}
//创建js书

var jb = new JsBook('js',60);

```