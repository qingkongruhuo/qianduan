# JavaScript 第九天

## 一、正则表达式

### 1.1 预定义类

预定一类表示一类字符，是一些特殊字符集的简写。是js提前给我们定义好的

​	.	[^\n\r] 表示除了换行和回车之外的任意字符。

​	\d	[0-9]		表示数字字符。

​	\D	[^0-9]		表示非数字字符。

​	\s	[ \t\n\x0B\f\r]      表示空白字符。

​	\S	[^ \t\n\x0B\f\r]	 表示非空白字符

​	\w	[a-zA-Z_0-9]	 表示单词字符(所有的字母/数字/下划线)。

​	\W	[^a-zA-Z_0-9]	 表示非单词字符

​	匹配中文：[\u4e00-\u9fa5]，是一个固定用法，中文只能在正则表达式里这样表示。

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
<script>
// 1检测是否是本地电话，如010-12345678,0418-1234567
// var reg = /[0-9]{3}-[0-9]{8}|[0-9]{4}-[0-9]{7}/
// \d代表数字
// var reg = /\d{3}-\d{8}|\d{4}-\d{7}/;
// console.log(reg.test('0418-1234567'));

// | 表示或，可以应用在分组中，实现局部或
// var a = 'abcafg';
// var reg = /a(bc)|a(fg)/g;
// 使用局部或
// var reg = /a(bc|fg)/g;
// console.log(a.replace(reg, 'a**'))
// 测试是不是图片  .gif, .png, .jpg, .css, .js, .html
// var reg = /\.(jpg|gif|png)/
// console.log(reg.test('a.png'));
// console.log(reg.test('b.html'));

// 匹配中文
var reg = /[\u4e00-\u9fa5]+/g

console.log(reg.test('hello'));
console.log(reg.test('你好'));
</script>
</body>
</html>
```



### 1.2 分组

用于处理多个重复的数据，通过()定义分组

​	分组的意义就是我们可以捕获它们（引用它们）

分组的反向引用

​	表示正则表达式匹配的字符串再次进行使用。\编号（正则表达式中使用），$编号（在正则表达式外使用）。编码从1开始，依次进行分组的

编码。1,2,3……

​	一个分组就是一个编码。只能在正则使用。

非捕获组：不会创建反向引用的分组

​	(?=exp)	表示其后紧接指定字符串的字符串

​	(?!exp)	表示其后没有紧接字符串的字符串

或操作符：|表示可能性，如 a|b|c

​	在分组中，使用或，可以实现局部或

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
<script>
// 密码：包含字母和数字
// 特点： 字母在前或者数字在前      adf%^&123       123^^*sdf
// var reg = /[a-zA-Z][^0-9a-zA-Z]*[0-9]|[0-9][^0-9a-zA-Z]*[a-zA-Z]/;
// console.log(reg.test('asdfsadf'));
// console.log(reg.test('123213'));
// console.log(reg.test('asfd123213'));
// console.log(reg.test('123213(&(*afd'));

// 1检测是否是本地电话，如010-12345678,0418-1234567
// 特点：前面是3位，后面是8位，或者 前面是4位后面是8位
// var reg = /[0-9]{3}-[0-9]{8}|[0-9]{4}-[0-9]{7}/
// console.log(reg.test('010-12345678'));
// console.log(reg.test('0418-1234567'));
// console.log(reg.test('010-1234567'));

// // 交换两个乘数位置
// var str = 'hello:123*456';
// // 456*123
// // 通过分组，将两个数字拆开
// // 第二个参数是一个函数，返回值就是替换的内容
// // console.log(str.replace(/([0-9]+)\*([0-9]+)/, function(match, $1, $2) {
// //     // console.log(arguments);
// //     // return 100
// //     return $2 + '*' + $1
// // }));
// // replace函数中只有返回值，可以直接写
// // 外部捕获用$
// // console.log(str.replace(/([0-9]+)\*([0-9]+)/, '$2*$1'))
// // 在内部捕获用\
// 注意，内部匹配，只能匹配前后值一样的
var str = 'hello:123*123';
// var str = 'hello:123*12';
console.log(str.replace(/([0-9]+)\*(\1)/, '$1+$2'))
// \1代表分组的内容（不包括圆括号，不会被分组，想分组要再外面加上()）
// console.log(str.replace(/([0-9]+)\*\1/, '$1+$2'))

// 从左向右查找圆括号，是几序号就代表几

// 交换两个乘数位置
var str = 'hello:123*456*789';
// 456*123
// 通过分组，将两个数字拆开
console.log(str.replace(/([0-9]+)\*([0-9]+)\*([0-9]+)/, '$2*$1+$3'))


// function add(fn) {
//     fn(100, 200)
// }
// add(function($1, $2) {
//     console.log($1, 111, $2)
// })

</script>
</body>
</html>
```



## 二、定时器

### 2.1 单次定时器

间隔一段时间后异步执行。

​	异步：脱离程序主线程，单独执行，不会堵塞后面程序的执行。

​	启动单次定时器：setTimeout(要执行的函数,时间单位毫秒,函数的参数1,函数的参数2...)		

​	清除单次定时器：clearTimeout(定时器名)
```js
//启动定时器
//过两秒钟打印hello
setTimeout(function(){
    console.log("hello");
},2000);
console.log("没有阻塞程序的正常运行")//可以看到立即打印这句话，两秒后打印hello，说明异步并不会阻塞现在的线程
```
```js
function demo(){
    console.log("hello");
}
var dingshiqi = setTimeout(demo,2000);
clearTimeout(dingshiqi);//清空 定时器，可以看到在两秒后并不会执行。
```

### 2.2  循环定时器

​	每一段时间，函数自动执行一次。

​		启动循环定时器：setInterval			

​		清除循环定时器：clearInterval

​	setTimeout与setInterval的参数需要两个

​		第一个参数：每一段时间要做的事情书写在函数内部。可以是匿名函数或者是函数名。

​		第二个参数：函数间隔多少时间。单位是ms。不用书写单位 1s = 1000ms

​		从第二个参数开始，表示传递给第一个参数函数的数据，

​		定时器调用对象是window。但是一般不用书写window.表示页面加载之后立即调用定时器。

​	clearTimeout与clearInterval参数：定时器的名字。

重新开启循环定时器时，一定要先清除原有定时器，否则会造成定时器叠加。

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
<script>
// 单次定时器
// console.log('start')
// // 过两秒钟打印hello
// // setTimeout(function() {
// //     console.log('hello')
// // }, 2000)
// // 传递具名函数
// // function demo() {
// //     console.log('hello')
// // }
// // setTimeout(demo, 2000)
// // 从第二个参数开始，表示传递的数据
// var timebar = setTimeout(function() {
//     console.log('hello', arguments)
// }, 2000, 'ickt', 100, true)
// // 清空定时器
// clearTimeout(timebar)
// // 定时器是异步的，不会堵塞后面程序的执行
// console.log('end')


// 循环定时器
console.log('start')
// 每隔1秒钟打印hello
// setInterval(function() {
//     console.log('hello')
// }, 1000)
// 传递具名函数
// var demo = function() {
//     console.log('hello')
// }
// setInterval(demo, 1000)
// 给回调函数传递参数
// 回调函数：给函数传递的参数函数就是回调函数。
//下面例子中，给setInterval函数传递的参数为匿名函数function，这个function就是回调函数
var timebar = setInterval(function() {
    console.log('hello', arguments)
}, 1000, 100, false, 'abc')
// 中断执行
clearInterval(timebar)
// 定时器是异步的，不会堵塞后面程序的执行
console.log('end')

</script>
</body>
</html>
```



## 三、DOM

### 3.1 DOM 概述

我们前面学习的都是JS语言核心部分，也就是ECMAScript。一般都是在控制台、输出语句里操作，JS还包括DOM和BOM。

DOM（Document Object Model，文档对象模型）描绘了一个层次化的节点树，允许开发人员添加、移除和修改页面的某一部分。这使得JavaScript操作HTML，不是在操作字符串，而是在操作节点，极大地降低了编程难度。

DOM对很多东西做了抽象，提供了丰富的API：取得元素、css样式、事件、运动、元素尺寸位置、节点操作等等。

![](./assets/1.png)

### 3.2 HTML 操作

document：表示文档（表示整个页面）对象。document对象具有页面几乎所有的方法或者属性。
    读取： document.title 页面的标题。
    赋值：使用=进行赋值。
一般操作元素都是从获取元素开始的。
    1、获取元素的方法： getElementById()通过id属性获取元素对象。
    通过id属性得到的元素对象的数据类型是对象<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    
</head>
<body>
    <div id="app" class="demo" color="red" style="color: red;">hello ickt</div>
    <script>
        //可以通过点语法设置属性
        //1、获取元素
        var app = document.getElementById("app");
        console.log(app);
        //getAttribute不需要将for写成htmlFor，不需要将class写成className
        console.log(app.getAttribute('class'),app.getAttribute('for'),);
        console.log(app.getAttribute('style'));//这里只是获得了一个字符串，
        console.log(app.style.color);//而点语法的.style可以获得style对象继续得到里面的细节属性

    </script>
</body>
</html>
    通过元素对象操作属性。
    2、读取：可以通过对象的点方法得到属性名。
    3、设置：用=进行赋值
    点语法只能读取或者设置元素的自带有属性不能设置读取元素的自定义属性。

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1 id="app" title="hello" style="color: green;" class="demo" color="red">hello ickt</h1>
    <!-- id不要同名 -->
    <!-- <h1 id="app">hello ickt 222</h1> -->
<script>
// 修改标题
document.title = '爱创课堂';
// 获取标题
console.log(document.title)// 打印了爱创课堂，且打开浏览器显示爱创课堂标签而不是hello ickt
// 获取head标签
console.log(document.head)
// 直接打印，
// <head>
//     <meta charset="UTF-8">
//     <meta name="viewport" content="width=device-width,       nitial-scale=1.0">
//     <title>Document</title>
// </head>，
// 获取body标签，同上
console.log(document.body)

// 获取h1元素
var app = document.getElementById('app');       // 获取第一个
// 早期为元素添加id的时候，会在js中创建一个同名变量
// console.log(app)，直接这么写也能得到
// <h1 id="app" title="hello" style="color: green;" class="demo" color="red">hello ickt</h1>
// console.log(a);
// 获取属性
console.log(app.id);//app
console.log(app.title);//hello
// style获取的是对象
console.log(app.style);//CSSStyleDeclaratiom{...}
// class要写成className， for要写成htmlFor
console.log(app.className);
console.log(app.color);//color是元素自定义属性不是自带属性。
// 修改属性
app.title = 'ickt'
app.className = 'ickt'
app.id = 'ickt'
</script>
</body>
</html>
```



### 3.3 属性操作

属性操作方法:之前说过点语法只能操作元素自带的属性，那么自定义的属性就可以用下面的方法来操作。

​	读取：getAttribute(属性名)  可以读取元素自带属性或者是自定义属性

​	设置：setAttribute(属性名，想修改的值);   设置元素自带属性或者是自定义属性或新增一个属性和对应的属性值。

点语法和getAttribute()，setAttribute()区别：

​	1 点语法只能读取或者设置元素的自带有属性，getAttribute()，setAttribute()可以读取元素自带属性或者是自定义属性

​	2 点语法操作有些属性名需要改名字，getAttribute()，setAttribute()不用改名，是什么就直接书写什么。

> class → className		
>
> for → htmlFor
>
> rowspan → rowSpan	
>
> colspan → colSpan

​	3 style属性：通过点语法得到的style对象，而getAttribute()得到的是字符串。

​	4 点语法得到style可以继续打点。而getAttribute()得到的是字符串不能继续打点调用属性。**点语法获取的css样式必须要遵循驼峰命名法**
app.style.fontSize;//100px，不能写font-size
**同样点语法可以给css新增样式**
app.style.backgroundColor='red';
**setAttribute给style设置属性会覆盖之前的属性**

总结：除了自定义属性使用getAttribute()，其他所有情况都使用点语法。
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    
</head>
<body>
    <div id="app" class="demo" color="red" style="color: red;">hello ickt</div>
    <script>
        //可以通过点语法设置属性
        //1、获取元素
        var app = document.getElementById("app");
        console.log(app);
        //getAttribute不需要将for写成htmlFor，不需要将class写成className
        console.log(app.getAttribute('class'),app.getAttribute('for'),);
        console.log(app.getAttribute('style'));//这里只是获得了一个字符串，
        console.log(app.style.color);//而点语法的.style可以获得style对象继续得到里面的细节属性
        //修改属性值
        app.setAttribute('class','ickt');
        //同理可以添加属性，点语法不行！！
        app.setAttribute('zhangyong','shuaige');//添加了一个属性zhangyong，值为shuaige
    </script>
</body>
</html>

### 3.4 DOM 事件

事件监听：我们计算机在解析我们JS代码的时候，会去看某一些元素身上是否添加了事件。并监听这些事件有没有被触发，如果触发就立即执行

相应的行为。

> onclick					 单击				
>
> ondblclick				双击
>
> onmouseenter		鼠标进入			
>
> onmouseleave		鼠标离开
>
> onmousedown		鼠标按下			
>
> onmouseup			鼠标弹起
>
> onfocus					获取焦点			
>
> onblur						失去焦点
>
> onload					加载完毕之后 window.onload();

元素绑定事件：元素.事件名 = fn。可以绑定匿名函数或者函数名（千万不要在函数名后面书写小括号，即不要让函数执行）。多次绑定后后面的会覆盖前面的。
window是一个全局对象，包含dom的一些API，例如可以通过window监听页面加载完成

注意：

​	我们在body中书写js时，需要将js书写在所有html元素之后。当html元素加载完毕之后在执行js。

​	如果js书写在head标签中，必须书写onload事件，window.onload表示当html元素加载完毕之后执行内部的语句。

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
<script>
// window是一个全局对象，包含dom的一些API，例如可以通过window监听页面加载完成
window.onload = function() {
    // 绑定事件监听用户与页面之间的交互。
    var app = document.getElementById('app')
    var inp = document.getElementById('inp')
    console.log(app, inp)
    // 监听点击h1元素
    // app.onclick = function() {
    //     console.log('click h1')
    // }
    // // 多次绑定，会导致后面的覆盖前面的，
    // app.onclick = function() {
    //     console.log('click h1 2222')
    // }
    // 双击
    // function fn() {
    //     console.log('click h1')
    // }
    // app.ondblclick = fn;
    // 鼠标移入和移出
    app.onmouseenter = function() {
        console.log('mouseenter')
    }
    app.onmouseleave = function() {
        console.log('onmouseleave')
    }
    // 输入框
    inp.onfocus = function() {
        console.log('获取焦点');
    }
    inp.onblur = function() {
        console.log('失去焦点');
    }
}

</script>
</head>
<body>
    <h1 id="app" class="demo" color="red" style="color: green; background: pink;">hello ickt</h1>
    <input id="inp" type="text" style="padding: 10px; margin-top: 50px;">
<script>
// // 绑定事件监听用户与页面之间的交互。
// var app = document.getElementById('app')
// var inp = document.getElementById('inp')
// // 监听点击h1元素
// // app.onclick = function() {
// //     console.log('click h1')
// // }
// // // 多次绑定，会导致后面的覆盖前面的，
// // app.onclick = function() {
// //     console.log('click h1 2222')
// // }
// // 双击
// // function fn() {
// //     console.log('click h1')
// // }
// // app.ondblclick = fn;
// // 鼠标移入和移出
// app.onmouseenter = function() {
//     console.log('mouseenter')
// }
// app.onmouseleave = function() {
//     console.log('onmouseleave')
// }
// // 输入框
// inp.onfocus = function() {
//     console.log('获取焦点');
// }
// inp.onblur = function() {
//     console.log('失去焦点');
// }


</script>
</body>
</html>
<script>
    console.log('页面加载完成了');
</script>
```



### 3.5 getElementsByTagName

getElementById()和getElementsByTagName()都是兼容IE低版本。全线兼容。

​	getElementsByClassName()通过类名获取元素不兼容IE低版本。

​	getElementsByTagName()通过元素的标签名得到元素。

​		**得到的是页面上所有的同种标签组成的类数组对象。**可以获取按照索引值找到元素，可以获取长度，就是不能用数组的方法

​			类数组中保存的每一个数据也是元素对象。

​			得到的类数组对象具有length属性。表示保存的同种标签的元素个数。

​			可以通过数组的索引值得到任何一个对象。

​		不管元素嵌套多深，getElementsByTagName("p")也可以查找。

​		类数组对象保存数据的顺序和标签之间的嵌套没有关系，和标签首次出现的顺序有关。例子在下面

### 3.6 批量操作

不但document可以打点调用getElementsByTagName()，其它元素对象也都可以打点调用该方法。

​	还可以将多条语句连续书写。（**getElementById只能被document调用，元素无法调用。**）

**通过getElementsByTagName("")得到的一定是类数组对象，即使只有一个元素也是类数组对象。想得到该元素对象，仍然需要书写索引值。**

批量操作事件

​	通过getElementsByTagName()得到的是类数组对象，我们可以通过批量操作的方式给数组每一个元素添加相同事件。

​	案例：给元素批量添加点击事件，触发事件弹出该元素对象的索引值

​	注意：事件回调函数中，存储索引值有两种方式

​		1 利用IIFE和闭包实现对数据的存储

​		2 通过this访问元素自身，再获取数据

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        div {
            font-size: 30px;
        }
    </style>
</head>
<body>
    <!-- <section id="app">
        <div>1
            <div>2
                <div id="div3">3
                    <div>4</div>
                </div>
            </div>
        </div>
    </section> -->
    <div>1</div>
    <div>2</div>
    <div>3</div>
    <div>4</div>
    <div>5</div>
    <div>6</div>
    <div>7</div>
<script>
// // 获取页面中所有div
// var divs = document.getElementsByTagName('div');
// // 遍历divs
// for (var i = 0; i < divs.length; i++) {
//     // 类数组对象，可以通过每一个索引值访问数组成员。
//     console.log(divs[i]);
// }
// console.log(divs)：会依次出现<div>1</div>,<div>2</div>...

// 后去section元素
// var app = document.getElementById('app');
// 通过app寻找其内部的div元素
// var divs = app.getElementsByTagName('div');
// console.log(divs)
// getElementById只能被document调用，元素无法调用。

// console.log(document.getElementsByTagName('section'));

// 批量的绑定事件
var divs = document.getElementsByTagName('div');
// 绑定事件
// for (var i = 0; i < divs.length; i++) {
//     // 绑定事件
//     divs[i].onclick = function() {
//         console.log(i)
//     }
// }
// 方案一 IIFE和闭包
// for (var i = 0; i < divs.length; i++) {
//     // 绑定事件
//     divs[i].onclick = (function(a) {
//         return function() {
//             console.log(a)
//         }
//     })(i + 1)
// }
// 方案二 通过this获取
// for (var i = 0; i < divs.length; i++) {
//     // 为元素添加一个属性，存储数据
//     // 获取的元素是对象，因此可以添加属性。
//     divs[i].index = i + 1;
//     // 绑定事件
//     divs[i].onclick = function() {
//         // this指向函数调用者，就是元素。
//         // console.log(this)
//         // 通过this访问元素。再访问属性
//         console.log(this.index)
//     }
// }

// 方案三 
for (var i = 0; i < divs.length; i++) {
    // 绑定事件
    divs[i].onclick = function() {
        // 由于这个案例中，元素的内容与索引值等价，因此可以将内容看成是索引值
        console.log(this.innerHTML);
    }
}

</script>
</body>
</html>
```





# Javascript 第十天

## 一、DOM 基础

### 1.1 对应与排它

我们一般习惯用一个元素去控制其它元素。根据它们之间的联系（索引值相同）进行书写。

​	排他：选中的元素改变其它元素，让其它元素变成原状。
举例：两个div app1和app2，里面都有4个p标签，对应：选择app1中的第i个p标签能让app2中的p标签文字变色。排他：再次选择app1的另一个p标签，能让第二个p标签之前变色的再变回来，实现方法:先排他将所有元素清空成默认样式，再实现对应。

要求：两组元素的个数得一样鸭

根据这一思想我们可以实现一些交互功能，如：选项卡的实现。

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .app {
            border: 1px solid #000;
            display: inline-block;
        }
        .app .header {
            line-height: 36px;
        }
        .app .header span {
            padding: 0 10px;
            font-size: 18px;
        }
        .app .header span.choose {
            color: #f30;
        }
        .app .body {
            height: 150px;
            padding: 10px;
        }
        .app .body p {
            display: none;
        }
        .app .body p.choose {
            display: block;
        }
    </style>
</head>
<body> 
    <div id="app" class="app">
        <!-- 默认选中第一个 -->
        <div class="header">
            <span class="choose">精选</span>
            <span>社会</span>
            <span>娱乐</span>
            <span>体育</span>
        </div>
        <div class="body">
            <p class="choose">精选新闻内容</p>
            <p>社会新闻内容</p>
            <p>娱乐新闻内容</p>
            <p>体育新闻内容</p>
        </div>
    </div>
<script>
// 获取元素
var app = document.getElementById('app');
// 获取span
var spans = app.getElementsByTagName('span');
// 后去p
var ps = app.getElementsByTagName('p');
// 绑定事件
for (var i = 0, len = spans.length; i < len; i++) {
    // 设置索引值
    spans[i].index = i;
    // 绑定事件
    spans[i].onclick = function() {
        // 排它法设置样式
        // 清除所有
        for (var j = 0; j < len; j++) {
            // 清除每一个span的类
            spans[j].className = '';
        }
        // 设置被点击的span的类
        spans[this.index].className = 'choose';
        // 对p使用排它
        for (var k = 0, klen = ps.length; k < klen; k++) {
            // 清除所有p的类
            ps[k].className = '';
        }
        // 设置特殊的：对应法
        ps[this.index].className = 'choose';
    }
}
</script>
</body>
</html>
```



### 1.2 样式计算

计算后的样式：指的是HTML元素在css各种选择器综合作用下，得到的最终样式。

高级浏览器的方法：window.getComputedStyle()，该方法接收一个要进行样式计算
的元素，并返回一个可以进行属性查询的接口。返回接口提供了一个名为
getPropertyValue()的方法，用于检索特定样式属性的计算样式。
getPropertyValue方法接收css属性名称，而不是驼峰式的名称。

getPropertyValue()可以不写，直接用方括号来检索属性也可以。

​	getComputedStyle：得到的样式是一个对象，包含了所有css样式。是window对象的方法
    注：也可以直接使用[]继续得到具体的计算后的属性值。（中括号中可以使用驼峰也可以使用短横）
    getPropertyValue：得到的是具体的某一个属性的值。参数和css书写一样，不
能使用驼峰

IE6,7,8方法

​	低版本浏览器不认识getComputedStyle。IE低版本计算后的方法，**是通过元素名.currentStyle()调用**。currentStyle.(对象打点调用currentStyle,继续打点调用具体的某个计算后的样式属性)。currentStyle也可以直接使用[]得到计算后的样式属性。注意：不管是中括号还是点语法都只能用驼峰命名法。(使用方法和style非常类似)

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        #app{
            color: red;
            width: 200px;
            height: 200px;
            background-color: green;
        }
    </style>
</head>
<body>
    <div id="app" style="color:red">
        hello
    </div>
    <script>
        var app = document.getElementById('app');
        //只能显示写在标签内的样式
        console.log(app.style.color);
        //不能显示写在css中的样式
        console.log(app.style.width);
        //window.getComputedStyle()获取计算样式
        var result = window.getComputedStyle(app);
        //getPropertyValue()获取width宽度值,注意里面写的是css属性名。
        console.log(result.getPropertyPriority('width'));
        //获取背景色
        console.log(result.getPropertyPriority('background-color'));
        //也可以用方括号直接获取，方括号里可以写css属性名也可以驼峰命名
        console.log(result['fontSize']);
        console.log(result['background-color']);
    </script>
</body>
</html>
```
### 1.3 能力检测

不管是低版本还是高级浏览器都可以正常输出计算后的样式。需要进行能力检测（就是判断认不认识window.getComoutedStyle）

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        #app {
            font-size: 40px;
            width: 200px;
            height: 200px;
            background-color: green;
            border-bottom-color: #000;
            border-bottom-width: 20px;
            border-bottom-style: solid;
        }
    </style>
</head>
<body>
    <div id="app" style="color: red;">
        hello
    </div>
<script>

/***
 * 封装一个getStyle方法，可以在不同浏览器下获取样式
 * @obj         元素对象
 * @key         属性名称
 * return       获取的样式
 **/
function getStyle(obj, key) {
    // 能力检测：判断浏览器的能力，能做什么就做什么
    // 浏览器是否支持getComponent方法，支持就使用
    //这里getComputedStyle是全局的方法，为什么还要用window去调用？
    //原因：假如说全局有getComputedStyle，那么直接写getComputedStyle()调用没任何问题，万一浏览器是ie没有这个方法，直接调用会报错的！但是用window.getComputedStyle()，哪怕没这个方法，只会出现undefined，不会报错，
    if (window.getComputedStyle) {
        // 通过该方法获取
        // 已经确定了该方法存在，就可以直接使用了
        // 方法一
        return getComputedStyle(obj)[key];
        // 方法二
        // 将key转成横杠法      borderLeftColor => border-left-color
        // key = key.replace(/([A-Z])/g, function(match, $1) {
        //     // 返回的是
        //     return '-' + $1.toLowerCase();
        // })
        // return getComputedStyle(obj).getPropertyValue(key);
    } else {
        var style = obj.currentStyle;
        // 如果有样式，可以获取
        if (style) {
            // 将横杠法转成驼峰式命名法    border-left-color => borderLeftColor
            key = key.replace(/-([a-z])?/g, function(match, $1) {
                return $1.toUpperCase();
            })
            // 返回样式
            return style[key]
        } else {
            // 没有样式，要提示
            alert('你的浏览器不支持获取计算样式功能。')
        }
    }
}

// 测试
// 获取元素
var app = document.getElementById('app');
alert(getStyle(app, 'color'));
alert(getStyle(app, 'fontSize'));
alert(getStyle(app, 'font-size'));

// function demo() {

// }
// console.log(demo)
// console.log(window.demo)

</script>
</body>
</html>
```



